"
" This file was automatically generated by riml 0.4.0
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

if exists('g:wordpress_vim_loaded')
  finish
endif
" included: 'app.riml'
" included: 'msg.riml'
function! s:echo_warn(...)
  call s:echo_with(a:000, 'WarningMsg')
endfunction

function! s:echo_error(...)
  call s:echo_with(a:000, 'ErrorMsg')
endfunction

function! s:echo_msg(...)
  if exists('g:speckle_mode')
    let logger = s:get_logger()
    let res = call(logger['info'], a:000, logger)
  else
    call s:echo_with(a:000, 'None')
  endif
endfunction

function! s:echo_with(args, style)
  if exists('g:speckle_mode')
    return
  endif
  let msg = join(a:args, ' ')
  execute ":echohl " . a:style
  echomsg msg
  echohl None
endfunction

" included: 'controller.riml'
" included: 'buffer_collection.riml'
" included: 'buffer.riml'
" included: 'buffer_type_detector.riml'
function! s:BufferTypeDetectorConstructor()
  let bufferTypeDetectorObj = {}
  let bufferTypeDetectorObj.get_project_path = function('<SNR>' . s:SID() . '_s:BufferTypeDetector_get_project_path')
  let bufferTypeDetectorObj.get_parent_path = function('<SNR>' . s:SID() . '_s:BufferTypeDetector_get_parent_path')
  let bufferTypeDetectorObj.is_core_path = function('<SNR>' . s:SID() . '_s:BufferTypeDetector_is_core_path')
  return bufferTypeDetectorObj
endfunction

function! <SID>s:BufferTypeDetector_get_project_path(path) dict
  let parent_path = self.get_parent_path(a:path)
  if self.is_core_path(parent_path)
    return parent_path
  else
    return a:path
  endif
endfunction

function! <SID>s:BufferTypeDetector_get_parent_path(path) dict
  let dirname = fnamemodify(a:path, ':t')
  if dirname ==# 'plugins' || dirname ==# 'mu-plugins'
    let parent_upto = ':h:h'
  else
    let parent_upto = ':h:h:h'
  endif
  return fnamemodify(a:path, parent_upto)
endfunction

function! <SID>s:BufferTypeDetector_is_core_path(path) dict
  let wp_load_path = a:path . "/wp-load.php"
  return filereadable(wp_load_path)
endfunction

" included: 'core_detector.riml'
function! s:CoreDetectorConstructor()
  let coreDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(coreDetectorObj, bufferTypeDetectorObj)
  let coreDetectorObj.detect = function('<SNR>' . s:SID() . '_s:CoreDetector_detect')
  let coreDetectorObj.get_type = function('<SNR>' . s:SID() . '_s:CoreDetector_get_type')
  return coreDetectorObj
endfunction

function! <SID>s:CoreDetector_detect(path) dict
  let found = findfile('wp-load.php', a:path . ";")
  let result = {}
  if found !=# ''
    let result.status = 1
    let result.path = fnamemodify(found, ':h')
  else
    let result.status = 0
    let result.path = ''
  endif
  return result
endfunction

function! <SID>s:CoreDetector_get_type() dict
  return 'core'
endfunction

" included: 'wpcli_detector.riml'
function! s:WpCliDetectorConstructor()
  let wpCliDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(wpCliDetectorObj, bufferTypeDetectorObj)
  let wpCliDetectorObj.detect = function('<SNR>' . s:SID() . '_s:WpCliDetector_detect')
  let wpCliDetectorObj.get_wp_cli_configs = function('<SNR>' . s:SID() . '_s:WpCliDetector_get_wp_cli_configs')
  let wpCliDetectorObj.has_wp_cli = function('<SNR>' . s:SID() . '_s:WpCliDetector_has_wp_cli')
  let wpCliDetectorObj.get_type = function('<SNR>' . s:SID() . '_s:WpCliDetector_get_type')
  return wpCliDetectorObj
endfunction

function! <SID>s:WpCliDetector_detect(path) dict
  let configs = self.get_wp_cli_configs()
  let result = {}
  let result.status = 0
  let result.path = ''
  for config in configs
    let found = self.has_wp_cli(config, a:path)
    if found !=# ''
      let result.status = 1
      let result.path = fnamemodify(found, ':h')
      break
    endif
  endfor
  return result
endfunction

function! <SID>s:WpCliDetector_get_wp_cli_configs() dict
  return ['wp-cli.local.yml', 'wp-cli.yml']
endfunction

function! <SID>s:WpCliDetector_has_wp_cli(config, path) dict
  return findfile(a:config, a:path . ";")
endfunction

function! <SID>s:WpCliDetector_get_type() dict
  return 'wpcli'
endfunction

" included: 'plugin_detector.riml'
function! s:PluginDetectorConstructor()
  let pluginDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(pluginDetectorObj, bufferTypeDetectorObj)
  let pluginDetectorObj.detect = function('<SNR>' . s:SID() . '_s:PluginDetector_detect')
  let pluginDetectorObj.is_plugin = function('<SNR>' . s:SID() . '_s:PluginDetector_is_plugin')
  let pluginDetectorObj.has_plugin_file = function('<SNR>' . s:SID() . '_s:PluginDetector_has_plugin_file')
  let pluginDetectorObj.has_plugin_header = function('<SNR>' . s:SID() . '_s:PluginDetector_has_plugin_header')
  let pluginDetectorObj.get_type = function('<SNR>' . s:SID() . '_s:PluginDetector_get_type')
  return pluginDetectorObj
endfunction

function! <SID>s:PluginDetector_detect(path) dict
  let parent = fnamemodify(a:path, ':p')
  let has_parent = 1
  let result = {}
  let result.status = 0
  let result.path = ''
  while has_parent
    if self.is_plugin(parent)
      let result.status = 1
      let result.path = self.get_project_path(parent)
      break
    endif
    let new_parent = fnamemodify(parent, ':h')
    let has_parent = new_parent !=# parent
    let parent = new_parent
  endwhile
  return result
endfunction

function! <SID>s:PluginDetector_is_plugin(path) dict
  let dirname = fnamemodify(a:path, ':t')
  if dirname ==# 'plugins' || dirname ==# 'mu-plugins'
    return 1
  else
    let plugin_file = a:path . "/" . dirname . ".php"
    return self.has_plugin_file(plugin_file) && self.has_plugin_header(plugin_file)
  endif
endfunction

function! <SID>s:PluginDetector_has_plugin_file(file) dict
  return filereadable(a:file)
endfunction

function! <SID>s:PluginDetector_has_plugin_header(file) dict
  let lines = readfile(a:file)
  for line in lines
    if line =~# '^\s*Plugin Name:'
      return 1
    endif
  endfor
  return 0
endfunction

function! <SID>s:PluginDetector_get_type() dict
  return 'plugin'
endfunction

" included: 'theme_detector.riml'
function! s:ThemeDetectorConstructor()
  let themeDetectorObj = {}
  let bufferTypeDetectorObj = s:BufferTypeDetectorConstructor()
  call extend(themeDetectorObj, bufferTypeDetectorObj)
  let themeDetectorObj.detect = function('<SNR>' . s:SID() . '_s:ThemeDetector_detect')
  let themeDetectorObj.get_wp_path = function('<SNR>' . s:SID() . '_s:ThemeDetector_get_wp_path')
  let themeDetectorObj.has_theme_header = function('<SNR>' . s:SID() . '_s:ThemeDetector_has_theme_header')
  let themeDetectorObj.get_type = function('<SNR>' . s:SID() . '_s:ThemeDetector_get_type')
  return themeDetectorObj
endfunction

function! <SID>s:ThemeDetector_detect(path) dict
  let found = findfile('style.css', a:path . ";")
  let result = {}
  if found !=# '' && self.has_theme_header(found)
    let result.status = 1
    let result.path = self.get_wp_path(found)
  else
    let result.status = 0
    let result.path = ''
  endif
  return result
endfunction

function! <SID>s:ThemeDetector_get_wp_path(found) dict
  let parent_path = fnamemodify(a:found, ':h')
  let core_path = fnamemodify(a:found, ':h:h:h:h')
  if self.is_core_path(core_path)
    return core_path
  else
    return parent_path
  endif
endfunction

function! <SID>s:ThemeDetector_has_theme_header(file) dict
  let lines = readfile(a:file)
  for line in lines
    if line =~# '^\s*Theme Name:'
      return 1
    endif
  endfor
  return 0
endfunction

function! <SID>s:ThemeDetector_get_type() dict
  return 'theme'
endfunction

function! s:BufferConstructor(path)
  let bufferObj = {}
  let bufferObj.path = a:path
  let bufferObj.did_scan = 0
  let bufferObj.project_path = ''
  let bufferObj.type = 'unknown'
  let bufferObj.scan = function('<SNR>' . s:SID() . '_s:Buffer_scan')
  let bufferObj.get_detectors = function('<SNR>' . s:SID() . '_s:Buffer_get_detectors')
  let bufferObj.get_type = function('<SNR>' . s:SID() . '_s:Buffer_get_type')
  let bufferObj.get_project_path = function('<SNR>' . s:SID() . '_s:Buffer_get_project_path')
  let bufferObj.get_path = function('<SNR>' . s:SID() . '_s:Buffer_get_path')
  let bufferObj.get_full_path = function('<SNR>' . s:SID() . '_s:Buffer_get_full_path')
  let bufferObj.get_parent_path = function('<SNR>' . s:SID() . '_s:Buffer_get_parent_path')
  let bufferObj.to_full_path = function('<SNR>' . s:SID() . '_s:Buffer_to_full_path')
  let bufferObj.destroy = function('<SNR>' . s:SID() . '_s:Buffer_destroy')
  return bufferObj
endfunction

function! <SID>s:Buffer_scan() dict
  for detector in self.get_detectors()
    let result = detector.detect(self.get_parent_path())
    if result.status ==# 1
      let self.type = detector.get_type()
      let self.project_path = self.to_full_path(result.path)
      return 1
    endif
  endfor
  return 0
endfunction

function! <SID>s:Buffer_get_detectors() dict
  let detectors = []
  call add(detectors, s:CoreDetectorConstructor())
  call add(detectors, s:WpCliDetectorConstructor())
  call add(detectors, s:PluginDetectorConstructor())
  call add(detectors, s:ThemeDetectorConstructor())
  return detectors
endfunction

function! <SID>s:Buffer_get_type() dict
  if !(self.did_scan)
    call self.scan()
  endif
  return self.type
endfunction

function! <SID>s:Buffer_get_project_path() dict
  if !(self.did_scan)
    call self.scan()
  endif
  return self.project_path
endfunction

function! <SID>s:Buffer_get_path() dict
  return self.path
endfunction

function! <SID>s:Buffer_get_full_path() dict
  if !(has_key(self, 'full_path'))
    let self.full_path = self.to_full_path(self.path)
  endif
  return self.full_path
endfunction

function! <SID>s:Buffer_get_parent_path() dict
  if !(has_key(self, 'parent_path'))
    let self.parent_path = self.to_full_path(fnamemodify(self.path, ':h'))
  endif
  return self.parent_path
endfunction

function! <SID>s:Buffer_to_full_path(path) dict
  let full_path = fnamemodify(a:path, ':p')
  if full_path =~# '/$'
    let full_path = strpart(full_path, 0, len(full_path) - 1)
  endif
  return full_path
endfunction

function! <SID>s:Buffer_destroy() dict
  unlet self.path
endfunction

function! s:BufferCollectionConstructor()
  let bufferCollectionObj = {}
  let bufferCollectionObj.buffers = {}
  let bufferCollectionObj.is_buffer_collection = 1
  let bufferCollectionObj.size = function('<SNR>' . s:SID() . '_s:BufferCollection_size')
  let bufferCollectionObj.add = function('<SNR>' . s:SID() . '_s:BufferCollection_add')
  let bufferCollectionObj.remove = function('<SNR>' . s:SID() . '_s:BufferCollection_remove')
  let bufferCollectionObj.contains = function('<SNR>' . s:SID() . '_s:BufferCollection_contains')
  let bufferCollectionObj.contains_path = function('<SNR>' . s:SID() . '_s:BufferCollection_contains_path')
  let bufferCollectionObj.buffer_for = function('<SNR>' . s:SID() . '_s:BufferCollection_buffer_for')
  let bufferCollectionObj.clear = function('<SNR>' . s:SID() . '_s:BufferCollection_clear')
  let bufferCollectionObj.set_current = function('<SNR>' . s:SID() . '_s:BufferCollection_set_current')
  let bufferCollectionObj.get_current = function('<SNR>' . s:SID() . '_s:BufferCollection_get_current')
  return bufferCollectionObj
endfunction

function! <SID>s:BufferCollection_size() dict
  return len(self.buffers)
endfunction

function! <SID>s:BufferCollection_add(buffer) dict
  let path = a:buffer.get_full_path()
  let self.buffers[path] = a:buffer
endfunction

function! <SID>s:BufferCollection_remove(buffer) dict
  let path = a:buffer.get_full_path()
  unlet self.buffers[path]
endfunction

function! <SID>s:BufferCollection_contains(buffer) dict
  return self.contains_path(a:buffer.get_full_path())
endfunction

function! <SID>s:BufferCollection_contains_path(path) dict
  return has_key(self.buffers, a:path)
endfunction

function! <SID>s:BufferCollection_buffer_for(path) dict
  return self.buffers[a:path]
endfunction

function! <SID>s:BufferCollection_clear() dict
  for buffer in values(self.buffers)
    call buffer.destroy()
  endfor
  let self.buffers = {}
endfunction

function! <SID>s:BufferCollection_set_current(buffer) dict
  if !(self.contains(a:buffer))
    call self.add(a:buffer)
  endif
  let self.current = a:buffer
endfunction

function! <SID>s:BufferCollection_get_current() dict
  return self.current
endfunction

" included: 'project_collection.riml'
" included: 'project.riml'
" included: 'wpcli_path.riml'
function! s:WpCliPathConstructor()
  let wpCliPathObj = {}
  let wpCliPathObj.did_find = 0
  let wpCliPathObj.get_path = function('<SNR>' . s:SID() . '_s:WpCliPath_get_path')
  let wpCliPathObj.exists = function('<SNR>' . s:SID() . '_s:WpCliPath_exists')
  let wpCliPathObj.find = function('<SNR>' . s:SID() . '_s:WpCliPath_find')
  let wpCliPathObj.is_executable = function('<SNR>' . s:SID() . '_s:WpCliPath_is_executable')
  let wpCliPathObj.vendor_cli_path = function('<SNR>' . s:SID() . '_s:WpCliPath_vendor_cli_path')
  return wpCliPathObj
endfunction

function! <SID>s:WpCliPath_get_path(root) dict
  if !(self.did_find)
    let self.cli_path = self.find(a:root)
    let self.did_find = 1
  endif
  return self.cli_path
endfunction

function! <SID>s:WpCliPath_exists(root) dict
  return self.get_path(a:root) !=# ''
endfunction

function! <SID>s:WpCliPath_find(root) dict
  let cli_path = self.vendor_cli_path(a:root)
  if self.is_executable(cli_path)
    return cli_path
  elseif self.is_executable('wp')
    return 'wp'
  else
    return ''
  endif
endfunction

function! <SID>s:WpCliPath_is_executable(path) dict
  if has_key(self, 'mock_is_executable')
    return self.mock_is_executable
  else
    return executable(a:path)
  endif
endfunction

function! <SID>s:WpCliPath_vendor_cli_path(root) dict
  return a:root . "/vendor/bin/wp"
endfunction

" included: 'wpcli_config.riml'
function! s:WpCliConfigConstructor()
  let wpCliConfigObj = {}
  let wpCliConfigObj.is_wpcli_config = 1
  let wpCliConfigObj.did_read = 0
  let wpCliConfigObj.params = {}
  let wpCliConfigObj.pattern = '\v^(.+):\s*(.+)$'
  let wpCliConfigObj.get_config_param = function('<SNR>' . s:SID() . '_s:WpCliConfig_get_config_param')
  let wpCliConfigObj.load = function('<SNR>' . s:SID() . '_s:WpCliConfig_load')
  let wpCliConfigObj.parse = function('<SNR>' . s:SID() . '_s:WpCliConfig_parse')
  let wpCliConfigObj.parse_line = function('<SNR>' . s:SID() . '_s:WpCliConfig_parse_line')
  let wpCliConfigObj.read = function('<SNR>' . s:SID() . '_s:WpCliConfig_read')
  let wpCliConfigObj.get_config_path = function('<SNR>' . s:SID() . '_s:WpCliConfig_get_config_path')
  let wpCliConfigObj.local_config_path_for = function('<SNR>' . s:SID() . '_s:WpCliConfig_local_config_path_for')
  let wpCliConfigObj.config_path_for = function('<SNR>' . s:SID() . '_s:WpCliConfig_config_path_for')
  let wpCliConfigObj.global_config_path_for = function('<SNR>' . s:SID() . '_s:WpCliConfig_global_config_path_for')
  return wpCliConfigObj
endfunction

function! <SID>s:WpCliConfig_get_config_param(param) dict
  if has_key(self.params, a:param)
    return self.params[a:param]
  else
    return ''
  endif
endfunction

function! <SID>s:WpCliConfig_load(root) dict
  let lines = self.read(a:root)
  call self.parse(lines)
endfunction

function! <SID>s:WpCliConfig_parse(lines) dict
  for line in a:lines
    let result = self.parse_line(line)
    if result.status
      let self.params[result.param] = result.value
    endif
  endfor
endfunction

function! <SID>s:WpCliConfig_parse_line(line) dict
  let matches = matchlist(a:line, self.pattern)
  let result = {}
  if len(matches) ># 0 && matches[2] !=# ' '
    let result.status = 1
    let result.param = matches[1]
    let result.value = matches[2]
  else
    let result.status = 0
  endif
  return result
endfunction

function! <SID>s:WpCliConfig_read(root) dict
  let config = self.get_config_path(a:root)
  if config !=# ''
    return readfile(config)
  else
    return []
  endif
endfunction

function! <SID>s:WpCliConfig_get_config_path(root) dict
  if has_key(self, 'config_path')
    return self.config_path
  endif
  let config = self.local_config_path_for(a:root)
  if !(filereadable(config))
    let config = self.config_path_for(a:root)
  endif
  if !(filereadable(config))
    let config = self.global_config_path_for(a:root)
  endif
  if !(filereadable(config))
    let config = ''
  endif
  let self.config_path = config
  return config
endfunction

function! <SID>s:WpCliConfig_local_config_path_for(root) dict
  return a:root . "/wp-cli.local.yml"
endfunction

function! <SID>s:WpCliConfig_config_path_for(root) dict
  return a:root . "/wp-cli.yml"
endfunction

function! <SID>s:WpCliConfig_global_config_path_for(root) dict
  return expand("~/.wp-cli/config.yml")
endfunction

" included: 'wpcli_printer.riml'
function! s:WpCliPrinterConstructor()
  let wpCliPrinterObj = {}
  let wpCliPrinterObj.is_wpcli_printer = 1
  let wpCliPrinterObj.print = function('<SNR>' . s:SID() . '_s:WpCliPrinter_print')
  let wpCliPrinterObj.print_json = function('<SNR>' . s:SID() . '_s:WpCliPrinter_print_json')
  let wpCliPrinterObj.print_text = function('<SNR>' . s:SID() . '_s:WpCliPrinter_print_text')
  let wpCliPrinterObj.replace = function('<SNR>' . s:SID() . '_s:WpCliPrinter_replace')
  let wpCliPrinterObj.get_command_pattern = function('<SNR>' . s:SID() . '_s:WpCliPrinter_get_command_pattern')
  let wpCliPrinterObj.get_help_pattern = function('<SNR>' . s:SID() . '_s:WpCliPrinter_get_help_pattern')
  let wpCliPrinterObj.get_command_replacement = function('<SNR>' . s:SID() . '_s:WpCliPrinter_get_command_replacement')
  let wpCliPrinterObj.get_help_replacement = function('<SNR>' . s:SID() . '_s:WpCliPrinter_get_help_replacement')
  let wpCliPrinterObj.print_line = function('<SNR>' . s:SID() . '_s:WpCliPrinter_print_line')
  let wpCliPrinterObj.replace_tabs = function('<SNR>' . s:SID() . '_s:WpCliPrinter_replace_tabs')
  let wpCliPrinterObj.replace_colors = function('<SNR>' . s:SID() . '_s:WpCliPrinter_replace_colors')
  let wpCliPrinterObj.is_json = function('<SNR>' . s:SID() . '_s:WpCliPrinter_is_json')
  let wpCliPrinterObj.lines_for = function('<SNR>' . s:SID() . '_s:WpCliPrinter_lines_for')
  return wpCliPrinterObj
endfunction

function! <SID>s:WpCliPrinter_print(cmd_name, result) dict
  if self.is_json(a:result)
    call self.print_json(a:cmd_name, a:result)
  else
    call self.print_text(a:cmd_name, a:result)
  endif
endfunction

function! <SID>s:WpCliPrinter_print_json(cmd_name, json) dict
  call s:echo_msg(a:json)
endfunction

function! <SID>s:WpCliPrinter_print_text(cmd_name, text) dict
  let text = self.replace(a:cmd_name, a:text)
  let lines = self.lines_for(text)
  for line in lines
    call self.print_line(line)
  endfor
endfunction

function! <SID>s:WpCliPrinter_replace(cmd_name, text) dict
  if a:cmd_name !=# ''
    let result = substitute(a:text, self.get_command_pattern(a:cmd_name), self.get_command_replacement(a:cmd_name), 'g')
    let result = substitute(result, self.get_help_pattern(a:cmd_name), self.get_help_replacement(a:cmd_name), 'g')
    let result = self.replace_colors(result)
  else
    let result = a:text
  endif
  return result
endfunction

function! <SID>s:WpCliPrinter_get_command_pattern(cmd_name) dict
  return "\\Vwp " . a:cmd_name
endfunction

function! <SID>s:WpCliPrinter_get_help_pattern(cmd_name) dict
  return "\\Vwp help " . a:cmd_name . " <command>"
endfunction

function! <SID>s:WpCliPrinter_get_command_replacement(cmd_name) dict
  let name = substitute(a:cmd_name, '\V-', '', 'g')
  return "W" . name
endfunction

function! <SID>s:WpCliPrinter_get_help_replacement(cmd_name) dict
  return self.get_command_replacement(a:cmd_name) . "!"
endfunction

function! <SID>s:WpCliPrinter_print_line(line) dict
  let text = self.replace_tabs(a:line)
  call s:echo_msg(text)
endfunction

function! <SID>s:WpCliPrinter_replace_tabs(line) dict
  return substitute(a:line, "\t", "  ", 'g')
endfunction

function! <SID>s:WpCliPrinter_replace_colors(line) dict
  return substitute(a:line, '\e\[[0-9;]\+[mK]', '', 'g')
endfunction

function! <SID>s:WpCliPrinter_is_json(result) dict
  return type(a:result) ==# type({})
endfunction

function! <SID>s:WpCliPrinter_lines_for(result) dict
  return split(a:result, "\n")
endfunction

" included: 'wpcli_completer.riml'
function! s:WpCliCompleterConstructor()
  let wpCliCompleterObj = {}
  let wpCliCompleterObj.needs = function('<SNR>' . s:SID() . '_s:WpCliCompleter_needs')
  let wpCliCompleterObj.complete = function('<SNR>' . s:SID() . '_s:WpCliCompleter_complete')
  let wpCliCompleterObj.trim_choices = function('<SNR>' . s:SID() . '_s:WpCliCompleter_trim_choices')
  let wpCliCompleterObj.trim = function('<SNR>' . s:SID() . '_s:WpCliCompleter_trim')
  let wpCliCompleterObj.to_complete_args = function('<SNR>' . s:SID() . '_s:WpCliCompleter_to_complete_args')
  let wpCliCompleterObj.to_cursor_arg = function('<SNR>' . s:SID() . '_s:WpCliCompleter_to_cursor_arg')
  let wpCliCompleterObj.to_line_arg = function('<SNR>' . s:SID() . '_s:WpCliCompleter_to_line_arg')
  let wpCliCompleterObj.to_wpcli_line = function('<SNR>' . s:SID() . '_s:WpCliCompleter_to_wpcli_line')
  return wpCliCompleterObj
endfunction

function! <SID>s:WpCliCompleter_needs() dict
  return ['wpcli']
endfunction

function! <SID>s:WpCliCompleter_complete(cmd_name, word, cmd_line, cursor) dict
  let args = self.to_complete_args(a:cmd_name, a:word, a:cmd_line, a:cursor)
  let result = call(self.wpcli['run'], args, self.wpcli)
  let choices = split(result, "\n")
  let choices = self.trim_choices(choices)
  return choices
endfunction

function! <SID>s:WpCliCompleter_trim_choices(choices) dict
  return map(a:choices, 'self.trim(v:val)')
endfunction

function! <SID>s:WpCliCompleter_trim(text) dict
  return substitute(a:text, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction

function! <SID>s:WpCliCompleter_to_complete_args(cmd_name, word, cmd_line, cursor) dict
  let args = []
  call add(args, 'cli')
  call add(args, 'completions')
  call add(args, self.to_line_arg(a:cmd_name, a:cmd_line))
  call add(args, self.to_cursor_arg(a:cmd_name, a:cursor))
  return args
endfunction

function! <SID>s:WpCliCompleter_to_cursor_arg(cmd_name, cursor) dict
  let arg = a:cursor + 2
  return "--point=" . arg
endfunction

function! <SID>s:WpCliCompleter_to_line_arg(cmd_name, cmd_line) dict
  let wpcli_line = self.to_wpcli_line(a:cmd_name, a:cmd_line)
  return "--line=\"" . wpcli_line . "\""
endfunction

function! <SID>s:WpCliCompleter_to_wpcli_line(cmd_name, cmd_line) dict
  let pattern = "\\VW" . a:cmd_name
  let replacement = "wp " . a:cmd_name
  return substitute(a:cmd_line, pattern, replacement, '')
endfunction

" included: 'wpcli_runner.riml'
function! s:WpCliRunnerConstructor()
  let wpCliRunnerObj = {}
  let wpCliRunnerObj.needs = function('<SNR>' . s:SID() . '_s:WpCliRunner_needs')
  let wpCliRunnerObj.run = function('<SNR>' . s:SID() . '_s:WpCliRunner_run')
  let wpCliRunnerObj.to_cli_params = function('<SNR>' . s:SID() . '_s:WpCliRunner_to_cli_params')
  let wpCliRunnerObj.wants_help = function('<SNR>' . s:SID() . '_s:WpCliRunner_wants_help')
  return wpCliRunnerObj
endfunction

function! <SID>s:WpCliRunner_needs() dict
  return ['wpcli', 'wpcli_printer']
endfunction

function! <SID>s:WpCliRunner_run(cmd_name, params, opts) dict
  let cli_params = self.to_cli_params(a:cmd_name, a:params, a:opts)
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  if !(has_key(a:opts, 'silent_cmd'))
    call self.wpcli_printer.print(a:cmd_name, result)
  endif
  return result
endfunction

function! <SID>s:WpCliRunner_to_cli_params(cmd_name, params, opts) dict
  if self.wants_help(a:opts)
    let cli_params = [a:cmd_name] + a:params + ['--help']
  else
    let cli_params = [a:cmd_name] + a:params
  endif
  return cli_params
endfunction

function! <SID>s:WpCliRunner_wants_help(opts) dict
  return has_key(a:opts, 'bang') && a:opts.bang
endfunction

" included: 'with_dir.riml'
" included: 'delegate.riml'
function! s:DelegateConstructor(scope, method)
  let delegateObj = {}
  let delegateObj.scope = a:scope
  let delegateObj.method = a:method
  let delegateObj.id = s:next_delegate_id()
  let delegateObj.unlinked = 0
  let delegateObj.invoke = function('<SNR>' . s:SID() . '_s:Delegate_invoke')
  let delegateObj.unlink = function('<SNR>' . s:SID() . '_s:Delegate_unlink')
  return delegateObj
endfunction

function! <SID>s:Delegate_invoke(...) dict
  if self.unlinked
    return
  endif
  return call(self.scope[self.method], a:000, self.scope)
endfunction

function! <SID>s:Delegate_unlink() dict
  let self.unlinked = 1
endfunction

let s:delegate_id_counter = 0
let s:delegate_instances = {}
function! s:next_delegate_id()
  let s:delegate_id_counter += 1
  return s:delegate_id_counter
endfunction

function! s:create_delegate(scope, method)
  let delegate = s:DelegateConstructor(a:scope, a:method)
  let id = delegate.id
  let s:delegate_instances[id] = delegate
  let delegate_name = "s:DelegateFunction" . id
  let delegate_func = "function! " . delegate_name . "(...)\n  let id = " . id . "\n  let NewDelegate = s:get_delegate_instance(id)\n  return call(NewDelegate.invoke, a:000, NewDelegate)\nendfunction"
  execute delegate_func
  let DelegateFuncRef = function(delegate_name)
  return DelegateFuncRef
endfunction

function! s:get_delegate_instance(id)
  return s:delegate_instances[a:id]
endfunction

function! s:remove_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  execute ":unlet s:delegate_instances[" . id . "]"
  execute ":delfunction " . func_name
endfunction

function! s:unlink_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  let delegate = s:get_delegate_instance(id)
  call delegate.unlink()
endfunction

function! s:get_delegate_name(Func)
  let func_def = string(a:Func)
  let sid = s:SID()
  let pattern = "\\v^function.{1}'(.*)'.{1}$"
  let result = substitute(func_def, pattern, '\1', '')
  let result = substitute(result, 's:', '<SNR>' . sid . '_', '')
  return result
endfunction

function! s:new_delegate(scope, method)
  return s:get_delegate_name(s:create_delegate(a:scope, a:method))
endfunction

function! s:WithDirConstructor(...)
  let __splat_var_cpy = copy(a:000)
  if !empty(__splat_var_cpy)
    let dir = remove(__splat_var_cpy, 0)
  else
    let dir = ''
  endif
  let withDirObj = {}
  let withDirObj.dir = dir
  let withDirObj.trap_errors = 1
  let withDirObj.set_dir = function('<SNR>' . s:SID() . '_s:WithDir_set_dir')
  let withDirObj.get_dir = function('<SNR>' . s:SID() . '_s:WithDir_get_dir')
  let withDirObj.get_trap_errors = function('<SNR>' . s:SID() . '_s:WithDir_get_trap_errors')
  let withDirObj.set_trap_errors = function('<SNR>' . s:SID() . '_s:WithDir_set_trap_errors')
  let withDirObj.run = function('<SNR>' . s:SID() . '_s:WithDir_run')
  return withDirObj
endfunction

function! <SID>s:WithDir_set_dir(dir) dict
  let self.dir = a:dir
endfunction

function! <SID>s:WithDir_get_dir() dict
  return self.dir
endfunction

function! <SID>s:WithDir_get_trap_errors() dict
  return self.trap_errors
endfunction

function! <SID>s:WithDir_set_trap_errors(trap_errors) dict
  let self.trap_errors = a:trap_errors
endfunction

function! <SID>s:WithDir_run(scope, method, args) dict
  let orig_dir = getcwd()
  if haslocaldir()
    let chdir_cmd = 'lcd'
  else
    let chdir_cmd = 'cd'
  endif
  execute ":" . chdir_cmd . " " . self.get_dir()
  if self.trap_errors
    try
      let result = call(a:scope[a:method], a:args, a:scope)
    catch
      let result = 0
    finally
      execute chdir_cmd . " " . orig_dir
    endtry
  else
    let result = call(a:scope[a:method], a:args, a:scope)
  endif
  return result
endfunction

" included: 'post.riml'
function! s:PostConstructor()
  let postObj = {}
  let postObj.is_post = 1
  let postObj.needs = function('<SNR>' . s:SID() . '_s:Post_needs')
  let postObj.create = function('<SNR>' . s:SID() . '_s:Post_create')
  let postObj.update = function('<SNR>' . s:SID() . '_s:Post_update')
  let postObj.find = function('<SNR>' . s:SID() . '_s:Post_find')
  let postObj.to_arg = function('<SNR>' . s:SID() . '_s:Post_to_arg')
  let postObj.to_post_id = function('<SNR>' . s:SID() . '_s:Post_to_post_id')
  return postObj
endfunction

function! <SID>s:Post_needs() dict
  return ['wpcli']
endfunction

function! <SID>s:Post_create(post_content, params) dict
  let cli_params = ['post', 'create', self.to_arg('post_content', a:post_content), '--porcelain']
  let cli_params += a:params
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  return self.to_post_id(result)
endfunction

function! <SID>s:Post_update(post_id, post_content, params) dict
  let cli_params = ['post', 'update', a:post_id, self.to_arg('post_content', a:post_content)]
  let cli_params += a:params
  return call(self.wpcli['run'], cli_params, self.wpcli)
endfunction

function! <SID>s:Post_find(post_id) dict
  let cli_params = ['post', 'get', a:post_id, '--format=json']
  let result = call(self.wpcli['run'], cli_params, self.wpcli)
  if has_key(result, 'post_content')
    return result['post_content']
  else
    return ''
  endif
endfunction

function! <SID>s:Post_to_arg(name, value) dict
  return "--" . a:name . "=" . shellescape(a:value)
endfunction

function! <SID>s:Post_to_post_id(result) dict
  let lines = split(a:result, "\n")
  if len(lines) >=# 0
    let post_id = lines[0]
  else
    let post_id = 0
  endif
  return post_id
endfunction

" included: 'ctags_builder.riml'
function! s:CTagsBuilderConstructor()
  let cTagsBuilderObj = {}
  let cTagsBuilderObj.is_ctags_builder = 1
  let cTagsBuilderObj.project_path = ''
  let cTagsBuilderObj.needs = function('<SNR>' . s:SID() . '_s:CTagsBuilder_needs')
  let cTagsBuilderObj.set_project_path = function('<SNR>' . s:SID() . '_s:CTagsBuilder_set_project_path')
  let cTagsBuilderObj.get_project_path = function('<SNR>' . s:SID() . '_s:CTagsBuilder_get_project_path')
  let cTagsBuilderObj.get_tags_name = function('<SNR>' . s:SID() . '_s:CTagsBuilder_get_tags_name')
  let cTagsBuilderObj.get_project_tags = function('<SNR>' . s:SID() . '_s:CTagsBuilder_get_project_tags')
  let cTagsBuilderObj.get_executable = function('<SNR>' . s:SID() . '_s:CTagsBuilder_get_executable')
  let cTagsBuilderObj.has_executable = function('<SNR>' . s:SID() . '_s:CTagsBuilder_has_executable')
  let cTagsBuilderObj.has_tags = function('<SNR>' . s:SID() . '_s:CTagsBuilder_has_tags')
  let cTagsBuilderObj.clean = function('<SNR>' . s:SID() . '_s:CTagsBuilder_clean')
  let cTagsBuilderObj.generate = function('<SNR>' . s:SID() . '_s:CTagsBuilder_generate')
  let cTagsBuilderObj.get_with_dir = function('<SNR>' . s:SID() . '_s:CTagsBuilder_get_with_dir')
  let cTagsBuilderObj.run = function('<SNR>' . s:SID() . '_s:CTagsBuilder_run')
  let cTagsBuilderObj.build = function('<SNR>' . s:SID() . '_s:CTagsBuilder_build')
  return cTagsBuilderObj
endfunction

function! <SID>s:CTagsBuilder_needs() dict
  return ['with_dir']
endfunction

function! <SID>s:CTagsBuilder_set_project_path(project_path) dict
  let self.project_path = a:project_path
endfunction

function! <SID>s:CTagsBuilder_get_project_path() dict
  return self.project_path
endfunction

function! <SID>s:CTagsBuilder_get_tags_name() dict
  if exists('g:wordpress_vim_tags_file_name')
    return g:wordpress_vim_tags_file_name
  else
    return "tags"
  endif
endfunction

function! <SID>s:CTagsBuilder_get_project_tags() dict
  return self.get_project_path() . "/" . self.get_tags_name()
endfunction

function! <SID>s:CTagsBuilder_get_executable() dict
  if exists('g:wordpress_vim_ctags_path')
    let ctags = g:wordpress_vim_ctags_path
  else
    let ctags = 'ctags'
  endif
  return ctags
endfunction

function! <SID>s:CTagsBuilder_has_executable() dict
  return executable(self.get_executable())
endfunction

function! <SID>s:CTagsBuilder_has_tags() dict
  return filereadable(self.get_project_tags())
endfunction

function! <SID>s:CTagsBuilder_clean() dict
  let tags = self.get_project_tags()
  if filereadable(tags)
    call delete(tags)
  endif
endfunction

function! <SID>s:CTagsBuilder_generate() dict
  if !(self.has_executable())
    return 0
  endif
  let cmd = self.build()
  let with_dir = self.get_with_dir()
  let [error_code, result] = self.with_dir.run(self, 'run', [cmd])
  return error_code ==# 0
endfunction

function! <SID>s:CTagsBuilder_get_with_dir() dict
  let with_dir = self.with_dir
  call with_dir.set_dir(self.get_project_path())
  return with_dir
endfunction

function! <SID>s:CTagsBuilder_run(cmd) dict
  let result = system(a:cmd)
  return [v:shell_error, result]
endfunction

function! <SID>s:CTagsBuilder_build() dict
  let cmd = self.get_executable()
  let cmd .= " -R ."
  let cmd .= " -f " . shellescape(self.get_tags_name())
  return cmd
endfunction

" included: 'command_registry.riml'
" included: 'command_builder.riml'
function! s:CommandBuilderConstructor()
  let commandBuilderObj = {}
  let commandBuilderObj.cmd_options = ''
  let commandBuilderObj.cmd_params = ''
  let commandBuilderObj.cmd_name = ''
  let commandBuilderObj.cmd_repr = ''
  let commandBuilderObj.ex_cmd_name = 'command!'
  let commandBuilderObj.ex_cmd = function('<SNR>' . s:SID() . '_s:CommandBuilder_ex_cmd')
  let commandBuilderObj.append_to = function('<SNR>' . s:SID() . '_s:CommandBuilder_append_to')
  let commandBuilderObj.option = function('<SNR>' . s:SID() . '_s:CommandBuilder_option')
  let commandBuilderObj.options = function('<SNR>' . s:SID() . '_s:CommandBuilder_options')
  let commandBuilderObj.param = function('<SNR>' . s:SID() . '_s:CommandBuilder_param')
  let commandBuilderObj.name = function('<SNR>' . s:SID() . '_s:CommandBuilder_name')
  let commandBuilderObj.repr = function('<SNR>' . s:SID() . '_s:CommandBuilder_repr')
  let commandBuilderObj.build = function('<SNR>' . s:SID() . '_s:CommandBuilder_build')
  return commandBuilderObj
endfunction

function! <SID>s:CommandBuilder_ex_cmd(ex_cmd_name) dict
  let self.ex_cmd_name = a:ex_cmd_name
endfunction

function! <SID>s:CommandBuilder_append_to(key, str) dict
  let key = "cmd_" . a:key
  let self[key] = self[key] . " " . a:str
endfunction

function! <SID>s:CommandBuilder_option(name, value) dict
  if type(a:value) ==# type(1)
    if a:value ==# 1
      call self.append_to('options', "-" . a:name)
    endif
  else
    call self.append_to('options', "-" . a:name . "=" . a:value)
  endif
endfunction

function! <SID>s:CommandBuilder_options(options) dict
  for [name, value] in items(a:options)
    call self.option(name, value)
  endfor
endfunction

function! <SID>s:CommandBuilder_param(name, value) dict
  call self.append_to('params', a:name . " " . a:value)
endfunction

function! <SID>s:CommandBuilder_name(cmd_name) dict
  if a:cmd_name =~# '_'
    let self.cmd_name = substitute(a:cmd_name, '_', '', 'g')
  else
    let self.cmd_name = a:cmd_name
  endif
endfunction

function! <SID>s:CommandBuilder_repr(repr) dict
  let self.cmd_repr = a:repr
endfunction

function! <SID>s:CommandBuilder_build() dict
  let cmd = self.ex_cmd_name . ' '
  let cmd .= self.cmd_options . ' '
  let cmd .= self.cmd_params . ' '
  let cmd .= self.cmd_name . ' '
  let cmd .= self.cmd_repr
  return cmd
endfunction

" included: 'ctrlp_extension.riml'
function! s:CtrlPExtensionConstructor()
  let ctrlPExtensionObj = {}
  let ctrlPExtensionObj.id_counter = 0
  let ctrlPExtensionObj.enabled = 0
  let ctrlPExtensionObj.inited = 0
  let ctrlPExtensionObj.next_id = function('<SNR>' . s:SID() . '_s:CtrlPExtension_next_id')
  let ctrlPExtensionObj.set_options = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_options')
  let ctrlPExtensionObj.get_options = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_options')
  let ctrlPExtensionObj.set_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_name')
  let ctrlPExtensionObj.get_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_name')
  let ctrlPExtensionObj.set_agent = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_agent')
  let ctrlPExtensionObj.get_agent = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_agent')
  let ctrlPExtensionObj.get_ext_vars = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_ext_vars')
  let ctrlPExtensionObj.get_id = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_id')
  let ctrlPExtensionObj.get_ex_cmd_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_ex_cmd_name')
  let ctrlPExtensionObj.enable = function('<SNR>' . s:SID() . '_s:CtrlPExtension_enable')
  let ctrlPExtensionObj.disable = function('<SNR>' . s:SID() . '_s:CtrlPExtension_disable')
  let ctrlPExtensionObj.show = function('<SNR>' . s:SID() . '_s:CtrlPExtension_show')
  let ctrlPExtensionObj.do_init = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_init')
  let ctrlPExtensionObj.do_accept = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_accept')
  let ctrlPExtensionObj.do_enter = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_enter')
  let ctrlPExtensionObj.do_exit = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_exit')
  let ctrlPExtensionObj.do_opts = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_opts')
  let ctrlPExtensionObj.get_callback = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_callback')
  let ctrlPExtensionObj.new_callback = function('<SNR>' . s:SID() . '_s:CtrlPExtension_new_callback')
  return ctrlPExtensionObj
endfunction

function! <SID>s:CtrlPExtension_next_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! <SID>s:CtrlPExtension_set_options(options) dict
  let self.options = a:options
endfunction

function! <SID>s:CtrlPExtension_get_options() dict
  return self.options
endfunction

function! <SID>s:CtrlPExtension_set_name(name) dict
  let self.name = a:name
  if self.enabled
    let opts = self.get_options()
    let opts.sname = a:name
    let opts.lname = a:name
  endif
endfunction

function! <SID>s:CtrlPExtension_get_name() dict
  return self.name
endfunction

function! <SID>s:CtrlPExtension_set_agent(agent) dict
  let self.agent = a:agent
endfunction

function! <SID>s:CtrlPExtension_get_agent() dict
  return self.agent
endfunction

function! <SID>s:CtrlPExtension_get_ext_vars() dict
  let opts = self.get_options()
  let opts.sname = self.get_name()
  let opts.lname = self.get_name()
  let opts.init = self.get_callback('init')
  let opts.accept = self.get_callback('accept')
  let opts.enter = self.get_callback('enter')
  let opts.exit = self.get_callback('exit')
  let opts.opts = self.get_callback('opts')
  return opts
endfunction

function! <SID>s:CtrlPExtension_get_id() dict
  return self.id
endfunction

function! <SID>s:CtrlPExtension_get_ex_cmd_name() dict
  return "CtrlP" . self.name
endfunction

function! <SID>s:CtrlPExtension_enable() dict
  if !(exists('g:ctrlp_ext_vars'))
    return
  endif
  let ext_vars = self.get_ext_vars()
  call add(g:ctrlp_ext_vars, ext_vars)
  let self.id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
  let ex_cmd = "command! " . self.get_ex_cmd_name() . " :call ctrlp#init(" . self.id . ")"
  execute ex_cmd
  let self.enabled = 1
  return ext_vars
endfunction

function! <SID>s:CtrlPExtension_disable() dict
  let self.enabled = 0
  if exists(":" . self.get_ex_cmd_name())
    execute ":delcommand " . self.get_ex_cmd_name()
  endif
endfunction

function! <SID>s:CtrlPExtension_show() dict
  if !(exists('g:speckle_mode'))
    call ctrlp#init(self.get_id())
  endif
endfunction

function! <SID>s:CtrlPExtension_do_init(...) dict
  if !(self.enabled)
    return []
  endif
  let self.inited = 1
  return self.agent.init()
endfunction

function! <SID>s:CtrlPExtension_do_accept(mode, str) dict
  if self.inited && !exists('g:speckle_mode')
    call ctrlp#exit()
    let self.inited = 0
  endif
  let result = self.agent.accept(a:mode, a:str)
  return result
endfunction

function! <SID>s:CtrlPExtension_do_enter(...) dict
  return self.agent.enter()
endfunction

function! <SID>s:CtrlPExtension_do_exit(...) dict
  return self.agent.exit()
endfunction

function! <SID>s:CtrlPExtension_do_opts(...) dict
  return self.agent.opts()
endfunction

function! <SID>s:CtrlPExtension_get_callback(method) dict
  let callback = self.new_callback(a:method)
  if !(a:method ==# 'accept')
    let callback = callback . "()"
  endif
  return callback
endfunction

function! <SID>s:CtrlPExtension_new_callback(method) dict
  let Callback = s:create_delegate(self, "do_" . a:method)
  return s:get_delegate_name(Callback)
endfunction

function! s:has_ctrlp_plugin()
  return exists('g:ctrlp_ext_vars')
endfunction

function! s:CommandRegistryConstructor()
  let commandRegistryObj = {}
  let commandRegistryObj.is_command_registry = 1
  let commandRegistryObj.commands = {}
  let commandRegistryObj.actions = {}
  let commandRegistryObj.id_counter = 0
  let commandRegistryObj.next_command_id = function('<SNR>' . s:SID() . '_s:CommandRegistry_next_command_id')
  let commandRegistryObj.add = function('<SNR>' . s:SID() . '_s:CommandRegistry_add')
  let commandRegistryObj.remove = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove')
  let commandRegistryObj.unregister = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister')
  let commandRegistryObj.remove_all = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_all')
  let commandRegistryObj.count = function('<SNR>' . s:SID() . '_s:CommandRegistry_count')
  let commandRegistryObj.auto_register = function('<SNR>' . s:SID() . '_s:CommandRegistry_auto_register')
  let commandRegistryObj.register = function('<SNR>' . s:SID() . '_s:CommandRegistry_register')
  let commandRegistryObj.register_ex_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ex_commands')
  let commandRegistryObj.register_ctrlp_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ctrlp_commands')
  let commandRegistryObj.remove_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_command')
  let commandRegistryObj.remove_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_action')
  let commandRegistryObj.unregister_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister_command')
  let commandRegistryObj.unregister_ctrlp_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister_ctrlp_command')
  let commandRegistryObj.find = function('<SNR>' . s:SID() . '_s:CommandRegistry_find')
  let commandRegistryObj.register_ex_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ex_command')
  let commandRegistryObj.command_has_name = function('<SNR>' . s:SID() . '_s:CommandRegistry_command_has_name')
  let commandRegistryObj.new_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_new_callback')
  let commandRegistryObj.get_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_callback')
  let commandRegistryObj.get_completer = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_completer')
  let commandRegistryObj.register_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_command')
  let commandRegistryObj.register_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_commands')
  let commandRegistryObj.run_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_run_command')
  let commandRegistryObj.run_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_run_action')
  let commandRegistryObj.complete_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_complete_command')
  let commandRegistryObj.is_cmd = function('<SNR>' . s:SID() . '_s:CommandRegistry_is_cmd')
  let commandRegistryObj.has_bang = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_bang')
  let commandRegistryObj.has_range = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_range')
  let commandRegistryObj.has_count = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_count')
  let commandRegistryObj.get_display_name = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_display_name')
  let commandRegistryObj.find_by_id = function('<SNR>' . s:SID() . '_s:CommandRegistry_find_by_id')
  let commandRegistryObj.has_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_action')
  let commandRegistryObj.register_ctrlp_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ctrlp_command')
  let commandRegistryObj.has_ctrlp = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_ctrlp')
  let commandRegistryObj.get_ctrlp_extension = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_extension')
  let commandRegistryObj.get_ctrlp_agent = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_agent')
  let commandRegistryObj.get_self_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_self_callback')
  let commandRegistryObj.get_ctrlp_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_callback')
  let commandRegistryObj.get_ctrlp_repr = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_repr')
  let commandRegistryObj.unlink = function('<SNR>' . s:SID() . '_s:CommandRegistry_unlink')
  return commandRegistryObj
endfunction

function! <SID>s:CommandRegistry_next_command_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! <SID>s:CommandRegistry_add(cmd) dict
  let id = self.next_command_id()
  let a:cmd.command_id = id
  let self.commands[id] = a:cmd
  let name = a:cmd.get_name()
  let self.actions[name] = id
  call self.auto_register(a:cmd)
endfunction

function! <SID>s:CommandRegistry_remove(cmd) dict
  call self.unregister_command(a:cmd)
  call self.remove_command(a:cmd.get_command_id())
endfunction

function! <SID>s:CommandRegistry_unregister() dict
  for cmd in values(self.commands)
    if cmd.has_ex_mode()
      call self.unregister_command(cmd)
    endif
    if cmd.has_ctrlp_mode()
      call self.unregister_ctrlp_command(cmd)
    endif
  endfor
endfunction

function! <SID>s:CommandRegistry_remove_all() dict
  for cmd in values(self.commands)
    call self.remove_command(cmd.get_command_id())
    call self.remove_action(cmd.get_name())
  endfor
endfunction

function! <SID>s:CommandRegistry_count() dict
  return len(self.commands)
endfunction

function! <SID>s:CommandRegistry_auto_register(cmd) dict
  if a:cmd.get_auto_register()
    call self.register(a:cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register(cmd) dict
  if a:cmd.has_ex_mode()
    call self.register_ex_commands(a:cmd)
  endif
  if a:cmd.has_ctrlp_mode()
    call self.register_ctrlp_commands(a:cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register_ex_commands(cmd) dict
  let options = a:cmd.get_options()
  let names = a:cmd.get_names()
  for name in names
    call self.register_ex_command(a:cmd, name, options, self.get_self_callback())
  endfor
  call a:cmd.set_registered(1)
endfunction

function! <SID>s:CommandRegistry_register_ctrlp_commands(cmd) dict
  let names = a:cmd.get_ctrlp_names()
  let options = {}
  let options.bang = 0
  let options.bar = 0
  let options.nargs = '0'
  let options.complete = 0
  for name in names
    let name = "CtrlP" . name
    call self.register_ctrlp_command(a:cmd, name, options)
  endfor
endfunction

function! <SID>s:CommandRegistry_remove_command(id) dict
  execute ":unlet self.commands[" . a:id . "]"
endfunction

function! <SID>s:CommandRegistry_remove_action(name) dict
  execute ":unlet self.actions['" . a:name . "']"
endfunction

function! <SID>s:CommandRegistry_unregister_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_names()
    for name in names
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! <SID>s:CommandRegistry_unregister_ctrlp_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_ctrlp_names()
    for name in names
      let name = "CtrlP" . name
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! <SID>s:CommandRegistry_find(cmd_line) dict
  for cmd in values(self.commands)
    let match = self.command_has_name(cmd, a:cmd_line)
    if match.ok
      let match.cmd = cmd
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! <SID>s:CommandRegistry_register_ex_command(cmd, name, options, Callback) dict
  let builder = s:CommandBuilderConstructor()
  let id = a:cmd.get_command_id()
  if type(a:options.complete) ==# type('string') && a:options.complete ==# 'customlist'
    let a:options.complete = self.get_completer(id, a:name)
  endif
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_callback(id, a:name, a:Callback))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! <SID>s:CommandRegistry_command_has_name(cmd, cmd_name) dict
  let names = a:cmd.get_names()
  for name in names
    if a:cmd_name =~# "^" . name
      let match = {}
      let match.ok = 1
      let match.name = name
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! <SID>s:CommandRegistry_new_callback() dict
  let Callback = s:create_delegate(self, 'run_command')
  return Callback
endfunction

function! <SID>s:CommandRegistry_get_callback(id, name, Callback) dict
  let callback_name = s:get_delegate_name(a:Callback)
  let opts = "{'bang':'<bang>', 'line1': <line1>, 'line2': <line2>, 'count': <count>})"
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "', [<f-args>], " . opts
endfunction

function! <SID>s:CommandRegistry_get_completer(id, name) dict
  let delegate = s:CompleteDelegateConstructor(self, a:id, a:name)
  let Callback = s:create_delegate(delegate, 'invoke')
  let callback_name = s:get_delegate_name(Callback)
  return "customlist," . callback_name
endfunction

function! <SID>s:CommandRegistry_register_command(id) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(cmd)
    call self.register(cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register_commands() dict
  for cmd in values(self.commands)
    call self.register(cmd)
  endfor
endfunction

function! <SID>s:CommandRegistry_run_command(id, match, args, options) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to run for id: " . a:id . ", name: " . a:match)
    return 0
  endif
  let a:options.match = a:match
  let a:options.bang = self.has_bang(a:args, a:options)
  if cmd.get_range() && self.has_range(a:args, a:options)
    let a:options.range = [a:options.line1, a:options.line2]
  endif
  if cmd.get_count()
    if !self.has_count(a:args, a:options)
      let a:options.count = 0
    endif
  else
    if self.has_count(a:args, a:options)
      unlet a:options['count']
    endif
  endif
  let arguments = a:args + [a:options]
  return call(cmd['run'], arguments, cmd)
endfunction

function! <SID>s:CommandRegistry_run_action(name, ...) dict
  if !(has_key(self.actions, a:name))
    call s:echo_warn("Warning: Unable to find action for name: " . a:name)
    return 0
  endif
  let n = len(a:000)
  if n >=# 1
    let last_arg = a:000[-1]
    if type(last_arg) ==# type({}) && has_key(last_arg, 'is_option') && last_arg.is_option ==# 1
      let opts = last_arg
      let params = a:000[0 : -2]
    else
      let opts = {}
      let params = a:000
    endif
  else
    let opts = {}
    let params = a:000
  endif
  let id = self.actions[a:name]
  return self.run_command(id, a:name, params, opts)
endfunction

function! <SID>s:CommandRegistry_complete_command(id, name, word, cmd_line, cursor) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to complete for id: " . a:id . ", name: " . match)
    return 0
  endif
  return cmd.complete(a:word, a:cmd_line, a:cursor)
endfunction

function! <SID>s:CommandRegistry_is_cmd(cmd) dict
  return type(a:cmd) !=# type(0)
endfunction

function! <SID>s:CommandRegistry_has_bang(args, options) dict
  let bang = has_key(a:options, 'bang') && a:options.bang !=# ''
  if !(bang)
    let nargs = len(a:args)
    if nargs ># 0
      let last_arg = a:args[-1]
      if type(last_arg) ==# type('') && last_arg =~# '!$'
        let bang = 1
        let a:args[-1] = strpart(last_arg, 0, len(last_arg) - 1)
      endif
    endif
  endif
  return bang
endfunction

function! <SID>s:CommandRegistry_has_range(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_has_count(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.line1 ==# a:options.line2 && a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_get_display_name(id, name) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(a:id)
    return cmd.get_display_name(a:name)
  endif
  return "UnknownCommand - " . a:name
endfunction

function! <SID>s:CommandRegistry_find_by_id(id) dict
  if has_key(self.commands, a:id)
    return self.commands[a:id]
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_has_action(name) dict
  return has_key(self.actions, a:name)
endfunction

function! <SID>s:CommandRegistry_register_ctrlp_command(cmd, name, options) dict
  let id = a:cmd.get_command_id()
  let builder = s:CommandBuilderConstructor()
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_ctrlp_repr(id, a:name))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! <SID>s:CommandRegistry_has_ctrlp() dict
  return exists('g:ctrlp_ext_vars')
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_extension() dict
  if !(has_key(self, 'ctrlp_extension'))
    let agent = self.get_ctrlp_agent()
    let self.ctrlp_options = {}
    let self.ctrlp_extension = s:CtrlPExtensionConstructor()
    call self.ctrlp_extension.set_name('Portkey')
    call self.ctrlp_extension.set_agent(agent)
    call self.ctrlp_extension.set_options(self.ctrlp_options)
    call self.ctrlp_extension.enable()
  endif
  return self.ctrlp_extension
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_agent() dict
  if !(has_key(self, 'ctrlp_agent'))
    let self.ctrlp_agent = s:CtrlPAgentConstructor(self)
  endif
  return self.ctrlp_agent
endfunction

function! <SID>s:CommandRegistry_get_self_callback() dict
  if !(has_key(self, 'Callback'))
    let self.Callback = self.new_callback()
  endif
  return self.Callback
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_callback() dict
  if !(has_key(self, 'CtrlPCallback'))
    let delegate = s:CtrlPDelegateConstructor(self.get_ctrlp_extension(), self)
    let self.CtrlPCallback = s:create_delegate(delegate, 'invoke')
  endif
  return self.CtrlPCallback
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_repr(id, name) dict
  let Callback = self.get_ctrlp_callback()
  let callback_name = s:get_delegate_name(Callback)
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "')"
endfunction

function! <SID>s:CommandRegistry_unlink() dict
  let Callback = self.get_self_callback()
  call s:unlink_delegate(Callback)
  unlet self.Callback
  let CtrlPCallback = self.get_ctrlp_callback()
  call s:unlink_delegate(CtrlPCallback)
  unlet self.CtrlPCallback
endfunction

function! s:CompleteDelegateConstructor(registry, id, name)
  let completeDelegateObj = {}
  let completeDelegateObj.registry = a:registry
  let completeDelegateObj.id = a:id
  let completeDelegateObj.name = a:name
  let completeDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:CompleteDelegate_invoke')
  return completeDelegateObj
endfunction

function! <SID>s:CompleteDelegate_invoke(word, cmd_line, cursor) dict
  return self.registry.complete_command(self.id, self.name, a:word, a:cmd_line, a:cursor)
endfunction

function! s:CtrlPDelegateConstructor(extension, registry)
  let ctrlPDelegateObj = {}
  let ctrlPDelegateObj.extension = a:extension
  let ctrlPDelegateObj.registry = a:registry
  let ctrlPDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:CtrlPDelegate_invoke')
  return ctrlPDelegateObj
endfunction

function! <SID>s:CtrlPDelegate_invoke(id, name) dict
  let agent = self.extension.get_agent()
  call agent.set_command(a:id, a:name)
  call self.extension.set_name(self.registry.get_display_name(a:id, a:name))
  call self.extension.show()
endfunction

function! s:CtrlPAgentConstructor(registry)
  let ctrlPAgentObj = {}
  let ctrlPAgentObj.registry = a:registry
  let ctrlPAgentObj.init = function('<SNR>' . s:SID() . '_s:CtrlPAgent_init')
  let ctrlPAgentObj.accept = function('<SNR>' . s:SID() . '_s:CtrlPAgent_accept')
  let ctrlPAgentObj.enter = function('<SNR>' . s:SID() . '_s:CtrlPAgent_enter')
  let ctrlPAgentObj.exit = function('<SNR>' . s:SID() . '_s:CtrlPAgent_exit')
  let ctrlPAgentObj.opts = function('<SNR>' . s:SID() . '_s:CtrlPAgent_opts')
  let ctrlPAgentObj.set_command = function('<SNR>' . s:SID() . '_s:CtrlPAgent_set_command')
  let ctrlPAgentObj.has_command = function('<SNR>' . s:SID() . '_s:CtrlPAgent_has_command')
  return ctrlPAgentObj
endfunction

function! <SID>s:CtrlPAgent_init() dict
  return self.registry.complete_command(self.command_id, self.resource_type, '', self.resource_type, 0)
endfunction

function! <SID>s:CtrlPAgent_accept(mode, str) dict
  let opts = {}
  let opts.mode = a:mode
  return self.registry.run_command(self.command_id, self.resource_type, [a:str], opts)
endfunction

function! <SID>s:CtrlPAgent_enter() dict
endfunction

function! <SID>s:CtrlPAgent_exit() dict
endfunction

function! <SID>s:CtrlPAgent_opts() dict
endfunction

function! <SID>s:CtrlPAgent_set_command(id, name) dict
  let self.command_id = a:id
  let self.resource_type = a:name
endfunction

function! <SID>s:CtrlPAgent_has_command() dict
  return has_key(self, 'command_id')
endfunction

" included: 'wpcli.riml'
" included: 'json_parser.riml'
function! s:JSONParserConstructor()
  let jSONParserObj = {}
  let jSONParserObj.parse = function('<SNR>' . s:SID() . '_s:JSONParser_parse')
  let jSONParserObj.clean = function('<SNR>' . s:SID() . '_s:JSONParser_clean')
  return jSONParserObj
endfunction

function! <SID>s:JSONParser_parse(str) dict
  try
    let text = self.clean(a:str)
    if has('python')
      let result = pyeval(text)
    else
      let result = eval(a:str)
    endif
    return result
  catch /.*/
    return 0
  endtry
endfunction

function! <SID>s:JSONParser_clean(text) dict
  let cleaned = substitute(a:text, ':true', ':1', 'g')
  let cleaned = substitute(cleaned, ':false', ':0', 'g')
  let cleaned = substitute(cleaned, ':null', ':""', 'g')
  return cleaned
endfunction

function! s:WpCliConstructor()
  let wpCliObj = {}
  let wpCliObj.is_wpcli = 1
  let wpCliObj.path = 'wp'
  let wpCliObj.env_vars = {}
  let wpCliObj.env_vars['SHELL_PIPE'] = 0
  let wpCliObj.set_path = function('<SNR>' . s:SID() . '_s:WpCli_set_path')
  let wpCliObj.get_path = function('<SNR>' . s:SID() . '_s:WpCli_get_path')
  let wpCliObj.add_env_var = function('<SNR>' . s:SID() . '_s:WpCli_add_env_var')
  let wpCliObj.remove_env_var = function('<SNR>' . s:SID() . '_s:WpCli_remove_env_var')
  let wpCliObj.get_env_vars = function('<SNR>' . s:SID() . '_s:WpCli_get_env_vars')
  let wpCliObj.build = function('<SNR>' . s:SID() . '_s:WpCli_build')
  let wpCliObj.exec = function('<SNR>' . s:SID() . '_s:WpCli_exec')
  let wpCliObj.parse = function('<SNR>' . s:SID() . '_s:WpCli_parse')
  let wpCliObj.get_parser = function('<SNR>' . s:SID() . '_s:WpCli_get_parser')
  let wpCliObj.run = function('<SNR>' . s:SID() . '_s:WpCli_run')
  let wpCliObj.dump = function('<SNR>' . s:SID() . '_s:WpCli_dump')
  let wpCliObj.list = function('<SNR>' . s:SID() . '_s:WpCli_list')
  return wpCliObj
endfunction

function! <SID>s:WpCli_set_path(path) dict
  let self.path = a:path
endfunction

function! <SID>s:WpCli_get_path() dict
  return self.path
endfunction

function! <SID>s:WpCli_add_env_var(key, value) dict
  let self.env_vars[a:key] = a:value
endfunction

function! <SID>s:WpCli_remove_env_var(key) dict
  unlet self.env_vars[a:key]
endfunction

function! <SID>s:WpCli_get_env_vars() dict
  let vars = ''
  for var in keys(self.env_vars)
    let vars .= var . "=" . self.env_vars[var] . " "
  endfor
  return vars
endfunction

function! <SID>s:WpCli_build(args) dict
  let env = self.get_env_vars()
  let cmd_args = join(a:args, ' ')
  let cmd = env . " " . self.path . " " . cmd_args
  return cmd
endfunction

function! <SID>s:WpCli_exec(args) dict
  let cmd = self.build(a:args)
  let result = system(cmd)
  if result[0] ==# '{'
    return self.parse(result)
  else
    return result
  endif
endfunction

function! <SID>s:WpCli_parse(text) dict
  return self.get_parser().parse(a:text)
endfunction

function! <SID>s:WpCli_get_parser() dict
  if !(has_key(self, 'parser'))
    let self.parser = s:JSONParserConstructor()
  endif
  return self.parser
endfunction

function! <SID>s:WpCli_run(...) dict
  return self.exec(a:000)
endfunction

function! <SID>s:WpCli_dump() dict
  return self.run('cli', 'cmd-dump', '--format=json')
endfunction

function! <SID>s:WpCli_list() dict
  let meta = self.dump()
  let cmds = []
  for cmd in meta.subcommands
    call add(cmds, cmd.name)
  endfor
  return cmds
endfunction

" included: 'wordpress_path.riml'
function! s:WordPressPathConstructor()
  let wordPressPathObj = {}
  let wordPressPathObj.needs = function('<SNR>' . s:SID() . '_s:WordPressPath_needs')
  let wordPressPathObj.get_path = function('<SNR>' . s:SID() . '_s:WordPressPath_get_path')
  let wordPressPathObj.get_detectors = function('<SNR>' . s:SID() . '_s:WordPressPath_get_detectors')
  let wordPressPathObj.find_wp_cli_project_path = function('<SNR>' . s:SID() . '_s:WordPressPath_find_wp_cli_project_path')
  let wordPressPathObj.to_abs_path = function('<SNR>' . s:SID() . '_s:WordPressPath_to_abs_path')
  let wordPressPathObj.calc_abs_path = function('<SNR>' . s:SID() . '_s:WordPressPath_calc_abs_path')
  return wordPressPathObj
endfunction

function! <SID>s:WordPressPath_needs() dict
  return ['wpcli_config', 'with_dir']
endfunction

function! <SID>s:WordPressPath_get_path(root) dict
  for detector in self.get_detectors()
    let result = detector.detect(a:root)
    let type = detector.get_type()
    if result.status && type ==# 'core'
      return result.path
    elseif result.status && type ==# 'wpcli'
      return self.find_wp_cli_project_path(a:root)
    endif
  endfor
  let path = self.find_wp_cli_project_path(a:root)
  if path ==# '' && exists('g:wordpress_vim_wordpress_path')
    let path = g:wordpress_vim_wordpress_path
  endif
  return path
endfunction

function! <SID>s:WordPressPath_get_detectors() dict
  let detectors = []
  call add(detectors, s:CoreDetectorConstructor())
  call add(detectors, s:WpCliDetectorConstructor())
  return detectors
endfunction

function! <SID>s:WordPressPath_find_wp_cli_project_path(root) dict
  let config = self.container.lookup('wpcli_config')
  let config_path = config.get_config_path(a:root)
  let config_parent = fnamemodify(config_path, ':h')
  call config.load(a:root)
  let project_path = config.get_config_param('path')
  if project_path !=# ''
    return self.to_abs_path(project_path, config_parent)
  else
    return ''
  endif
endfunction

function! <SID>s:WordPressPath_to_abs_path(project_path, parent_dir) dict
  let with_dir = self.container.lookup('with_dir')
  call with_dir.set_dir(a:parent_dir)
  return with_dir.run(self, 'calc_abs_path', [a:project_path])
endfunction

function! <SID>s:WordPressPath_calc_abs_path(project_path) dict
  let path = fnamemodify(a:project_path, ':p')
  let path = substitute(path, '/$', '', '')
  return path
endfunction

" included: 'wpcli_command_factory.riml'
" included: 'wordpress_command.riml'
" included: 'base_command.riml'
function! s:BaseCommandConstructor()
  let baseCommandObj = {}
  let baseCommandObj.get_command_id = function('<SNR>' . s:SID() . '_s:BaseCommand_get_command_id')
  let baseCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_s:BaseCommand_get_auto_register')
  let baseCommandObj.get_auto_unregister = function('<SNR>' . s:SID() . '_s:BaseCommand_get_auto_unregister')
  let baseCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:BaseCommand_has_ex_mode')
  let baseCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:BaseCommand_has_ctrlp_mode')
  let baseCommandObj.set_registered = function('<SNR>' . s:SID() . '_s:BaseCommand_set_registered')
  let baseCommandObj.has_registered = function('<SNR>' . s:SID() . '_s:BaseCommand_has_registered')
  let baseCommandObj.get_name = function('<SNR>' . s:SID() . '_s:BaseCommand_get_name')
  let baseCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:BaseCommand_get_aliases')
  let baseCommandObj.get_names = function('<SNR>' . s:SID() . '_s:BaseCommand_get_names')
  let baseCommandObj.get_ctrlp_aliases = function('<SNR>' . s:SID() . '_s:BaseCommand_get_ctrlp_aliases')
  let baseCommandObj.get_ctrlp_names = function('<SNR>' . s:SID() . '_s:BaseCommand_get_ctrlp_names')
  let baseCommandObj.get_display_name = function('<SNR>' . s:SID() . '_s:BaseCommand_get_display_name')
  let baseCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:BaseCommand_get_bang')
  let baseCommandObj.get_bar = function('<SNR>' . s:SID() . '_s:BaseCommand_get_bar')
  let baseCommandObj.get_nargs = function('<SNR>' . s:SID() . '_s:BaseCommand_get_nargs')
  let baseCommandObj.get_buffer = function('<SNR>' . s:SID() . '_s:BaseCommand_get_buffer')
  let baseCommandObj.get_register = function('<SNR>' . s:SID() . '_s:BaseCommand_get_register')
  let baseCommandObj.get_completer = function('<SNR>' . s:SID() . '_s:BaseCommand_get_completer')
  let baseCommandObj.get_range = function('<SNR>' . s:SID() . '_s:BaseCommand_get_range')
  let baseCommandObj.get_count = function('<SNR>' . s:SID() . '_s:BaseCommand_get_count')
  let baseCommandObj.get_options = function('<SNR>' . s:SID() . '_s:BaseCommand_get_options')
  let baseCommandObj.complete = function('<SNR>' . s:SID() . '_s:BaseCommand_complete')
  let baseCommandObj.run = function('<SNR>' . s:SID() . '_s:BaseCommand_run')
  return baseCommandObj
endfunction

function! <SID>s:BaseCommand_get_command_id() dict
  return self.command_id
endfunction

function! <SID>s:BaseCommand_get_auto_register() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_auto_unregister() dict
  return 1
endfunction

function! <SID>s:BaseCommand_has_ex_mode() dict
  return 0
endfunction

function! <SID>s:BaseCommand_has_ctrlp_mode() dict
  return 0
endfunction

function! <SID>s:BaseCommand_set_registered(registered) dict
  let self.registered = a:registered
endfunction

function! <SID>s:BaseCommand_has_registered() dict
  return has_key(self, 'registered') && self.registered
endfunction

function! <SID>s:BaseCommand_get_name() dict
  return 'BaseCommand'
endfunction

function! <SID>s:BaseCommand_get_aliases() dict
  return []
endfunction

function! <SID>s:BaseCommand_get_names() dict
  return [self.get_name()] + self.get_aliases()
endfunction

function! <SID>s:BaseCommand_get_ctrlp_aliases() dict
  return self.get_aliases()
endfunction

function! <SID>s:BaseCommand_get_ctrlp_names() dict
  return self.get_ctrlp_aliases()
endfunction

function! <SID>s:BaseCommand_get_display_name(cmd_name) dict
  return substitute(a:cmd_name, 'CtrlP', '', '')
endfunction

function! <SID>s:BaseCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_bar() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_nargs() dict
  return '*'
endfunction

function! <SID>s:BaseCommand_get_buffer() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_register() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_completer() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_range() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_count() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_options() dict
  let opts = {}
  let opts.bang = self.get_bang()
  let opts.bar = self.get_bar()
  let opts.nargs = self.get_nargs()
  let opts.buffer = self.get_buffer()
  let opts.register = self.get_register()
  let opts.complete = self.get_completer()
  let opts.range = self.get_range()
  let opts.count = self.get_count()
  return opts
endfunction

function! <SID>s:BaseCommand_complete(word, cmd_line, cursor) dict
  return []
endfunction

function! <SID>s:BaseCommand_run(...) dict
endfunction

function! s:WordPressCommandConstructor(container)
  let wordPressCommandObj = {}
  let baseCommandObj = s:BaseCommandConstructor()
  call extend(wordPressCommandObj, baseCommandObj)
  let wordPressCommandObj.container = a:container
  let wordPressCommandObj.lookup = function('<SNR>' . s:SID() . '_s:WordPressCommand_lookup')
  let wordPressCommandObj.process = function('<SNR>' . s:SID() . '_s:WordPressCommand_process')
  let wordPressCommandObj.current_buffer = function('<SNR>' . s:SID() . '_s:WordPressCommand_current_buffer')
  let wordPressCommandObj.current_buffer_full_path = function('<SNR>' . s:SID() . '_s:WordPressCommand_current_buffer_full_path')
  let wordPressCommandObj.current_buffer_project_path = function('<SNR>' . s:SID() . '_s:WordPressCommand_current_buffer_project_path')
  let wordPressCommandObj.current_project = function('<SNR>' . s:SID() . '_s:WordPressCommand_current_project')
  let wordPressCommandObj.expand_args = function('<SNR>' . s:SID() . '_s:WordPressCommand_expand_args')
  return wordPressCommandObj
endfunction

function! <SID>s:WordPressCommand_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! <SID>s:WordPressCommand_process(...) dict
  let registry = self.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! <SID>s:WordPressCommand_current_buffer() dict
  return self.lookup('buffer_collection').get_current()
endfunction

function! <SID>s:WordPressCommand_current_buffer_full_path() dict
  return self.current_buffer().get_full_path()
endfunction

function! <SID>s:WordPressCommand_current_buffer_project_path() dict
  return self.current_buffer().get_project_path()
endfunction

function! <SID>s:WordPressCommand_current_project() dict
  return self.lookup('project_collection').project_for(self.current_buffer_project_path())
endfunction

function! <SID>s:WordPressCommand_expand_args(args) dict
  let n = len(a:args)
  let opts = a:args[n - 1]
  let params = a:args[0 : -2]
  return [params, opts]
endfunction

" included: 'wpcli_command.riml'
" included: 'wordpress_project_command.riml'
function! s:WordPressProjectCommandConstructor(container)
  let wordPressProjectCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(wordPressProjectCommandObj, wordPressCommandObj)
  let wordPressProjectCommandObj.lookup = function('<SNR>' . s:SID() . '_s:WordPressProjectCommand_lookup')
  return wordPressProjectCommandObj
endfunction

function! <SID>s:WordPressProjectCommand_lookup(key) dict
  let buffer_collection = self.container.lookup('buffer_collection')
  let project_collection = self.container.lookup('project_collection')
  let current_buffer = buffer_collection.get_current()
  let project_path = current_buffer.get_project_path()
  let project = project_collection.project_for(project_path)
  return project.lookup(a:key)
endfunction

function! s:WpCliCommandConstructor(container)
  let wpCliCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(wpCliCommandObj, wordPressProjectCommandObj)
  let wpCliCommandObj.is_wpcli_command = 1
  let wpCliCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_auto_register')
  let wpCliCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:WpCliCommand_has_ex_mode')
  let wpCliCommandObj.get_completer = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_completer')
  let wpCliCommandObj.get_name = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_name')
  let wpCliCommandObj.set_cmd_name = function('<SNR>' . s:SID() . '_s:WpCliCommand_set_cmd_name')
  let wpCliCommandObj.get_cmd_name = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_cmd_name')
  let wpCliCommandObj.complete = function('<SNR>' . s:SID() . '_s:WpCliCommand_complete')
  let wpCliCommandObj.run = function('<SNR>' . s:SID() . '_s:WpCliCommand_run')
  let wpCliCommandObj.get_with_dir = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_with_dir')
  let wpCliCommandObj.do_run = function('<SNR>' . s:SID() . '_s:WpCliCommand_do_run')
  let wpCliCommandObj.do_complete = function('<SNR>' . s:SID() . '_s:WpCliCommand_do_complete')
  let wpCliCommandObj.has_hyphen = function('<SNR>' . s:SID() . '_s:WpCliCommand_has_hyphen')
  let wpCliCommandObj.get_dehyphenated_name = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_dehyphenated_name')
  let wpCliCommandObj.get_dehyphenated_cmd_line = function('<SNR>' . s:SID() . '_s:WpCliCommand_get_dehyphenated_cmd_line')
  return wpCliCommandObj
endfunction

function! <SID>s:WpCliCommand_get_auto_register() dict
  return 0
endfunction

function! <SID>s:WpCliCommand_has_ex_mode() dict
  return 1
endfunction

function! <SID>s:WpCliCommand_get_completer() dict
  return 'customlist'
endfunction

function! <SID>s:WpCliCommand_get_name() dict
  if self.has_hyphen()
    return "W" . self.get_dehyphenated_name()
  else
    return "W" . self.get_cmd_name()
  endif
endfunction

function! <SID>s:WpCliCommand_set_cmd_name(cmd_name) dict
  let self.cmd_name = a:cmd_name
endfunction

function! <SID>s:WpCliCommand_get_cmd_name() dict
  return self.cmd_name
endfunction

function! <SID>s:WpCliCommand_complete(word, cmd_line, cursor) dict
  let line = a:cmd_line
  let point = a:cursor
  if self.has_hyphen()
    let line = self.get_dehyphenated_cmd_line(a:cmd_line)
    let point = a:cursor + 1
  endif
  return self.do_complete(a:word, line, point)
endfunction

function! <SID>s:WpCliCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  return self.do_run(params, opts)
endfunction

function! <SID>s:WpCliCommand_get_with_dir() dict
  let with_dir = self.lookup('with_dir')
  call with_dir.set_dir(self.current_buffer_project_path())
  return with_dir
endfunction

function! <SID>s:WpCliCommand_do_run(params, opts) dict
  let runner = self.lookup('wpcli_runner')
  let with_dir = self.get_with_dir()
  return with_dir.run(runner, 'run', [self.get_cmd_name(), a:params, a:opts])
endfunction

function! <SID>s:WpCliCommand_do_complete(word, line, point) dict
  let completer = self.lookup('wpcli_completer')
  let with_dir = self.get_with_dir()
  return with_dir.run(completer, 'complete', [self.get_cmd_name(), a:word, a:line, a:point])
endfunction

function! <SID>s:WpCliCommand_has_hyphen() dict
  return self.get_cmd_name() =~# '-'
endfunction

function! <SID>s:WpCliCommand_get_dehyphenated_name() dict
  return substitute(self.get_cmd_name(), '\V-', '', 'g')
endfunction

function! <SID>s:WpCliCommand_get_dehyphenated_cmd_line(cmd_line) dict
  return substitute(a:cmd_line, "\\V" . self.get_dehyphenated_name(), self.get_cmd_name(), '')
endfunction

" included: 'eval_file_command.riml'
function! s:EvalFileCommandConstructor(container)
  let evalFileCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(evalFileCommandObj, wpCliCommandObj)
  let evalFileCommandObj.is_eval_file_command = 1
  let evalFileCommandObj.run = function('<SNR>' . s:SID() . '_s:EvalFileCommand_run')
  return evalFileCommandObj
endfunction

function! <SID>s:EvalFileCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ==# 0
    call add(params, self.current_buffer_full_path())
  endif
  return self.do_run(params, opts)
endfunction

" included: 'eval_command.riml'
function! s:EvalCommandConstructor(container)
  let evalCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(evalCommandObj, wpCliCommandObj)
  let evalCommandObj.is_eval_command = 1
  let evalCommandObj.get_range = function('<SNR>' . s:SID() . '_s:EvalCommand_get_range')
  let evalCommandObj.run = function('<SNR>' . s:SID() . '_s:EvalCommand_run')
  let evalCommandObj.to_eval_text = function('<SNR>' . s:SID() . '_s:EvalCommand_to_eval_text')
  return evalCommandObj
endfunction

function! <SID>s:EvalCommand_get_range() dict
  return 1
endfunction

function! <SID>s:EvalCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  if len(params) ># 0
    let params = self.to_eval_text(params)
  elseif has_key(opts, 'range')
    let params = self.to_eval_text(getline(opts.line1, opts.line2))
  endif
  return self.do_run(params, opts)
endfunction

function! <SID>s:EvalCommand_to_eval_text(params) dict
  let text = join(a:params, ' ')
  return [shellescape(text)]
endfunction

" included: 'post_command.riml'
" included: 'autocmd_loader.riml'
function! s:AutocmdLoaderConstructor()
  let autocmdLoaderObj = {}
  let autocmdLoaderObj.cmds = []
  let autocmdLoaderObj.set_group_name = function('<SNR>' . s:SID() . '_s:AutocmdLoader_set_group_name')
  let autocmdLoaderObj.get_group_name = function('<SNR>' . s:SID() . '_s:AutocmdLoader_get_group_name')
  let autocmdLoaderObj.load = function('<SNR>' . s:SID() . '_s:AutocmdLoader_load')
  let autocmdLoaderObj.unload = function('<SNR>' . s:SID() . '_s:AutocmdLoader_unload')
  let autocmdLoaderObj.cmd = function('<SNR>' . s:SID() . '_s:AutocmdLoader_cmd')
  let autocmdLoaderObj.size = function('<SNR>' . s:SID() . '_s:AutocmdLoader_size')
  return autocmdLoaderObj
endfunction

function! <SID>s:AutocmdLoader_set_group_name(group_name) dict
  let self.group_name = a:group_name
endfunction

function! <SID>s:AutocmdLoader_get_group_name() dict
  return self.group_name
endfunction

function! <SID>s:AutocmdLoader_load() dict
  execute ":augroup " . self.get_group_name()
  execute ":autocmd!"
  for cmd in self.cmds
    execute ":autocmd " . cmd
  endfor
  execute ":augroup END"
endfunction

function! <SID>s:AutocmdLoader_unload() dict
  execute ":augroup " . self.group_name
  execute ":autocmd!"
  execute ":augroup END"
endfunction

function! <SID>s:AutocmdLoader_cmd(ex_cmd) dict
  call add(self.cmds, a:ex_cmd)
endfunction

function! <SID>s:AutocmdLoader_size() dict
  return len(self.cmds)
endfunction

" included: 'post_saver.riml'
function! s:PostSaverConstructor()
  let postSaverObj = {}
  let postSaverObj.post_id = '0'
  let postSaverObj.params = []
  let postSaverObj.needs = function('<SNR>' . s:SID() . '_s:PostSaver_needs')
  let postSaverObj.set_post_id = function('<SNR>' . s:SID() . '_s:PostSaver_set_post_id')
  let postSaverObj.get_post_id = function('<SNR>' . s:SID() . '_s:PostSaver_get_post_id')
  let postSaverObj.watch = function('<SNR>' . s:SID() . '_s:PostSaver_watch')
  let postSaverObj.before_file_save = function('<SNR>' . s:SID() . '_s:PostSaver_before_file_save')
  let postSaverObj.after_file_save = function('<SNR>' . s:SID() . '_s:PostSaver_after_file_save')
  let postSaverObj.load_current_buffer = function('<SNR>' . s:SID() . '_s:PostSaver_load_current_buffer')
  let postSaverObj.post_exists = function('<SNR>' . s:SID() . '_s:PostSaver_post_exists')
  let postSaverObj.message_for = function('<SNR>' . s:SID() . '_s:PostSaver_message_for')
  return postSaverObj
endfunction

function! <SID>s:PostSaver_needs() dict
  return ['post', 'wpcli_printer']
endfunction

function! <SID>s:PostSaver_set_post_id(post_id) dict
  let self.post_id = a:post_id
endfunction

function! <SID>s:PostSaver_get_post_id() dict
  return self.post_id
endfunction

function! <SID>s:PostSaver_watch(path, params) dict
  let self.params = a:params
  let loader = s:AutocmdLoaderConstructor()
  call loader.set_group_name('wordpress_vim_post_buffer')
  call loader.cmd("BufWritePre " . a:path . " call " . s:new_delegate(self, 'before_file_save') . "()")
  call loader.cmd("BufWritePost " . a:path . " call " . s:new_delegate(self, 'after_file_save') . "()")
  call loader.load()
endfunction

function! <SID>s:PostSaver_before_file_save() dict
  let self.modified = &mod
endfunction

function! <SID>s:PostSaver_after_file_save() dict
  if !(self.modified)
    return
  endif
  let post_content = self.load_current_buffer()
  if self.post_exists()
    let result = self.post.update(self.post_id, post_content, self.params)
  else
    let self.post_id = self.post.create(post_content, self.params)
    let result = self.message_for(self.post_id)
  endif
  call self.wpcli_printer.print('post', result)
  return result
endfunction

function! <SID>s:PostSaver_load_current_buffer() dict
  return join(getline(1, '$'), "\n")
endfunction

function! <SID>s:PostSaver_post_exists() dict
  return self.post_id !=# '0'
endfunction

function! <SID>s:PostSaver_message_for(post_id) dict
  if a:post_id !=# '0'
    return "Success: Created post " . a:post_id . "."
  else
    return "Error: Failed to create post."
  endif
endfunction

function! s:PostCommandConstructor(container)
  let postCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(postCommandObj, wpCliCommandObj)
  let postCommandObj.is_post_command = 1
  let postCommandObj.run = function('<SNR>' . s:SID() . '_s:PostCommand_run')
  let postCommandObj.load_post_into = function('<SNR>' . s:SID() . '_s:PostCommand_load_post_into')
  let postCommandObj.get_temp_file = function('<SNR>' . s:SID() . '_s:PostCommand_get_temp_file')
  let postCommandObj.open_temp_buffer = function('<SNR>' . s:SID() . '_s:PostCommand_open_temp_buffer')
  let postCommandObj.get_post_options = function('<SNR>' . s:SID() . '_s:PostCommand_get_post_options')
  return postCommandObj
endfunction

function! <SID>s:PostCommand_run(...) dict
  let [params, opts] = self.expand_args(a:000)
  let post_options = self.get_post_options(params, opts)
  let action = post_options.action
  let post_params = post_options.options
  let temp_file = self.get_temp_file()
  if action ==# 'create'
    let post_id = '0'
  elseif action ==# 'edit'
    let post_id = remove(post_params, 0)
    call self.load_post_into(post_id, temp_file)
  endif
  if (action ==# 'create' || action ==# 'edit') && !opts.bang
    call self.open_temp_buffer(temp_file)
    let post_saver = self.lookup('post_saver')
    call post_saver.set_post_id(post_id)
    call post_saver.watch(temp_file, post_params)
  else
    call self.do_run(params, opts)
  endif
endfunction

function! <SID>s:PostCommand_load_post_into(post_id, path) dict
  let post = self.lookup('post')
  let post_content = post.find(a:post_id)
  if post_content !=# ''
    let lines = split(post_content, "\n")
    call writefile(lines, a:path)
  endif
endfunction

function! <SID>s:PostCommand_get_temp_file() dict
  return tempname()
endfunction

function! <SID>s:PostCommand_open_temp_buffer(path) dict
  if &hidden
    execute ":edit " . a:path
  else
    execute ":tabedit " . a:path
  endif
endfunction

function! <SID>s:PostCommand_get_post_options(params, opts) dict
  let post_options = s:PostOptionsConstructor()
  return post_options.parse(a:params, a:opts)
endfunction

function! s:PostOptionsConstructor()
  let postOptionsObj = {}
  let postOptionsObj.parse = function('<SNR>' . s:SID() . '_s:PostOptions_parse')
  let postOptionsObj.parse_params = function('<SNR>' . s:SID() . '_s:PostOptions_parse_params')
  return postOptionsObj
endfunction

function! <SID>s:PostOptions_parse(params, opts) dict
  let total_params = len(a:params)
  if (total_params ># 0)
    return self.parse_params(a:params, a:opts)
  else
    return {'action': 'help', 'options': []}
  endif
endfunction

function! <SID>s:PostOptions_parse_params(params, opts) dict
  let post_params = a:params[0 :]
  let action = remove(post_params, 0)
  let result = {}
  let result.action = action
  let result.options = post_params
  return result
endfunction

" included: 'scaffold_command.riml'
" included: 'file_opener.riml'
function! s:FileOpenerConstructor()
  let fileOpenerObj = {}
  let fileOpenerObj.is_file_opener = 1
  let fileOpenerObj.mkdir_mode = 1
  let fileOpenerObj.exec_mode = 1
  let fileOpenerObj.exec_cmd = ''
  let fileOpenerObj.exec_mkdir = ''
  let fileOpenerObj.set_mkdir_mode = function('<SNR>' . s:SID() . '_s:FileOpener_set_mkdir_mode')
  let fileOpenerObj.get_mkdir_mode = function('<SNR>' . s:SID() . '_s:FileOpener_get_mkdir_mode')
  let fileOpenerObj.set_exec_mode = function('<SNR>' . s:SID() . '_s:FileOpener_set_exec_mode')
  let fileOpenerObj.get_exec_mode = function('<SNR>' . s:SID() . '_s:FileOpener_get_exec_mode')
  let fileOpenerObj.open = function('<SNR>' . s:SID() . '_s:FileOpener_open')
  let fileOpenerObj.open_with = function('<SNR>' . s:SID() . '_s:FileOpener_open_with')
  let fileOpenerObj.mkdir = function('<SNR>' . s:SID() . '_s:FileOpener_mkdir')
  let fileOpenerObj.build_cmd = function('<SNR>' . s:SID() . '_s:FileOpener_build_cmd')
  return fileOpenerObj
endfunction

function! <SID>s:FileOpener_set_mkdir_mode(mkdir_mode) dict
  let self.mkdir_mode = a:mkdir_mode
endfunction

function! <SID>s:FileOpener_get_mkdir_mode() dict
  return self.mkdir_mode
endfunction

function! <SID>s:FileOpener_set_exec_mode(exec_mode) dict
  let self.exec_mode = a:exec_mode
endfunction

function! <SID>s:FileOpener_get_exec_mode() dict
  return self.exec_mode
endfunction

function! <SID>s:FileOpener_open(file, mode) dict
  let cmd = self.build_cmd(a:file, a:mode)
  call self.mkdir(a:file)
  call self.open_with(cmd)
endfunction

function! <SID>s:FileOpener_open_with(cmd) dict
  if self.exec_mode
    execute a:cmd
  else
    let self.exec_cmd = a:cmd
  endif
endfunction

function! <SID>s:FileOpener_mkdir(file) dict
  let parent_dir = fnamemodify(a:file, ':p:h')
  if !isdirectory(parent_dir) && self.mkdir_mode
    if self.exec_mode
      if exists('*mkdir')
        call mkdir(parent_dir, 'p')
      endif
    else
      let self.exec_mkdir = parent_dir
    endif
  endif
endfunction

function! <SID>s:FileOpener_build_cmd(file, mode) dict
  let cmd = ''
  if a:mode ==# 'e' || a:mode ==# 'edit'
    let cmd = 'edit'
  elseif a:mode ==# 's' || a:mode ==# 'h' || a:mode ==# 'split'
    let cmd = 'split'
  elseif a:mode ==# 'v' || a:mode ==# 'vsplit'
    let cmd = 'vsplit'
  elseif a:mode ==# 't' || a:mode ==# 'tab'
    let cmd = 'tabedit'
  elseif a:mode ==# 'd' || a:mode ==# 'read'
    let cmd = 'read'
  elseif a:mode ==# 'abo' || a:mode ==# 'aboveleft' || a:mode ==# 'lefta' || a:mode ==# 'leftabove'
    let cmd = 'leftabove'
  elseif a:mode ==# 'rightb' || a:mode ==# 'rightbelow' || a:mode ==# 'bel' || a:mode ==# 'belowright'
    let cmd = 'rightbelow'
  elseif a:mode ==# 'to' || a:mode ==# 'topleft'
    let cmd = 'topleft'
  elseif a:mode ==# 'bo' || a:mode ==# 'botright'
    let cmd = 'botright'
  else
    let cmd = 'edit'
  endif
  let cmd = ":" . cmd . " " . a:file
  return cmd
endfunction

function! s:ScaffoldCommandConstructor(container)
  let scaffoldCommandObj = {}
  let wpCliCommandObj = s:WpCliCommandConstructor(a:container)
  call extend(scaffoldCommandObj, wpCliCommandObj)
  let scaffoldCommandObj.is_scaffold_command = 1
  let scaffoldCommandObj.do_run = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_do_run')
  let scaffoldCommandObj.get_underscore_theme_file = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_get_underscore_theme_file')
  let scaffoldCommandObj.open_file = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_open_file')
  let scaffoldCommandObj.get_file_open_mode = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_get_file_open_mode')
  let scaffoldCommandObj.find_scaffold_file = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_find_scaffold_file')
  let scaffoldCommandObj.insert_into_buffer = function('<SNR>' . s:SID() . '_s:ScaffoldCommand_insert_into_buffer')
  let scaffoldCommandObj.WpCliCommand_do_run = function('<SNR>' . s:SID() . '_s:WpCliCommand_do_run')
  return scaffoldCommandObj
endfunction

function! <SID>s:ScaffoldCommand_do_run(params, opts) dict
  let action = a:params[0]
  let file_to_open = ''
  if action ==# 'post-type' || action ==# 'taxonomy'
    let a:opts.silent_cmd = 1
    let insert_output = 1
  else
    let insert_output = 0
  endif
  let result = self.WpCliCommand_do_run(a:params, a:opts)
  if insert_output
    call self.insert_into_buffer(a:opts.line1, result)
  endif
  if action ==# 'child-theme'
    let file_to_open = self.find_scaffold_file(result, 'style.css')
  elseif action ==# 'plugin'
    let plugin_name = a:params[1]
    let file_to_open = self.find_scaffold_file(result, plugin_name . ".php")
  elseif action ==# '_s'
    let theme_name = a:params[1]
    let file_to_open = self.get_underscore_theme_file(theme_name)
  endif
  if file_to_open !=# ''
    call self.open_file(file_to_open)
  endif
  return result
endfunction

function! <SID>s:ScaffoldCommand_get_underscore_theme_file(theme_name) dict
  let project = self.current_project()
  let wordpress_path = project.get_wordpress_path()
  let theme_path = wordpress_path . "/wp-content/themes/" . a:theme_name . "/style.css"
  return theme_path
endfunction

function! <SID>s:ScaffoldCommand_open_file(path) dict
  if !(filereadable(a:path))
    return 0
  endif
  let file_opener = self.lookup('file_opener')
  call file_opener.open(a:path, self.get_file_open_mode())
  return 1
endfunction

function! <SID>s:ScaffoldCommand_get_file_open_mode() dict
  if &hidden
    return 'edit'
  else
    return 'tabedit'
  endif
endfunction

function! <SID>s:ScaffoldCommand_find_scaffold_file(result, file_name) dict
  let lines = split(a:result, "\n")
  let text = lines[0]
  let pattern = "\\v^.*Success:.*Created (.*)$"
  let matches = matchlist(text, pattern)
  if len(matches) ># 0
    let theme_dir = matches[1]
    let file = theme_dir . "/" . a:file_name
    let file = fnamemodify(file, ':.')
  else
    let file = ''
  endif
  return file
endfunction

function! <SID>s:ScaffoldCommand_insert_into_buffer(line_num, text) dict
  execute ":" . a:line_num . "put=a:text"
endfunction

function! s:WpCliCommandFactoryConstructor()
  let wpCliCommandFactoryObj = {}
  let wpCliCommandFactoryObj.build = function('<SNR>' . s:SID() . '_s:WpCliCommandFactory_build')
  let wpCliCommandFactoryObj.command_for = function('<SNR>' . s:SID() . '_s:WpCliCommandFactory_command_for')
  return wpCliCommandFactoryObj
endfunction

function! <SID>s:WpCliCommandFactory_build(cmd_name) dict
  let cmd = self.command_for(a:cmd_name)
  if cmd.is_wpcli_command
    call cmd.set_cmd_name(a:cmd_name)
  endif
  return cmd
endfunction

function! <SID>s:WpCliCommandFactory_command_for(cmd_name) dict
  if a:cmd_name ==# 'eval-file'
    let cmd = s:EvalFileCommandConstructor(self.container)
  elseif a:cmd_name ==# 'eval'
    let cmd = s:EvalCommandConstructor(self.container)
  elseif a:cmd_name ==# 'post'
    let cmd = s:PostCommandConstructor(self.container)
  elseif a:cmd_name ==# 'scaffold'
    let cmd = s:ScaffoldCommandConstructor(self.container)
  elseif a:cmd_name ==# 'shell'
    let cmd = {'is_wpcli_command': 0}
  else
    let cmd = s:WpCliCommandConstructor(self.container)
  endif
  return cmd
endfunction

function! s:ProjectConstructor()
  let projectObj = {}
  let projectObj.is_project = 1
  let projectObj.cli_exists = 0
  let projectObj.wordpress_project_path = ''
  let projectObj.commands = []
  let projectObj.on_inject = function('<SNR>' . s:SID() . '_s:Project_on_inject')
  let projectObj.lookup = function('<SNR>' . s:SID() . '_s:Project_lookup')
  let projectObj.load = function('<SNR>' . s:SID() . '_s:Project_load')
  let projectObj.get_root = function('<SNR>' . s:SID() . '_s:Project_get_root')
  let projectObj.get_commands = function('<SNR>' . s:SID() . '_s:Project_get_commands')
  let projectObj.load_commands = function('<SNR>' . s:SID() . '_s:Project_load_commands')
  let projectObj.has_cli = function('<SNR>' . s:SID() . '_s:Project_has_cli')
  let projectObj.get_wordpress_path = function('<SNR>' . s:SID() . '_s:Project_get_wordpress_path')
  let projectObj.has_wordpress_path = function('<SNR>' . s:SID() . '_s:Project_has_wordpress_path')
  let projectObj.destroy = function('<SNR>' . s:SID() . '_s:Project_destroy')
  let projectObj.load_wpcli = function('<SNR>' . s:SID() . '_s:Project_load_wpcli')
  let projectObj.load_wordpress_path = function('<SNR>' . s:SID() . '_s:Project_load_wordpress_path')
  let projectObj.load_ctags_builder = function('<SNR>' . s:SID() . '_s:Project_load_ctags_builder')
  let projectObj.get_wpcli = function('<SNR>' . s:SID() . '_s:Project_get_wpcli')
  return projectObj
endfunction

function! <SID>s:Project_on_inject() dict
  let self.container = self.container.child()
  call self.container.register('wpcli_command_factory', 'WpCliCommandFactory', 1)
  call self.container.register('project_registry', 'CommandRegistry', 1)
  call self.container.register('wpcli', 'WpCli', 1)
  call self.container.register('wpcli_path', 'WpCliPath', 1)
  call self.container.register('wpcli_config', 'WpCliConfig', 1)
  call self.container.register('wpcli_completer', 'WpCliCompleter', 1)
  call self.container.register('wpcli_printer', 'WpCliPrinter', 1)
  call self.container.register('wpcli_runner', 'WpCliRunner', 1)
  call self.container.register('wordpress_path', 'WordPressPath', 1)
  call self.container.register('post', 'Post', 1)
  call self.container.register('post_saver', 'PostSaver', 0)
  call self.container.register('ctags_builder', 'CTagsBuilder', 1)
endfunction

function! <SID>s:Project_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! <SID>s:Project_load(root) dict
  let self.root = a:root
  call self.load_wpcli(a:root)
  call self.load_wordpress_path(a:root)
  call self.load_ctags_builder(a:root)
  if self.has_cli()
    let self.commands = self.get_wpcli().list()
    call self.load_commands()
    return 1
  else
    return 0
  endif
endfunction

function! <SID>s:Project_get_root() dict
  return self.root
endfunction

function! <SID>s:Project_get_commands() dict
  return self.commands
endfunction

function! <SID>s:Project_load_commands() dict
  let factory = self.lookup('wpcli_command_factory')
  let registry = self.lookup('project_registry')
  for command_name in self.commands
    let cmd = factory.build(command_name)
    if cmd.is_wpcli_command
      call registry.add(cmd)
    endif
  endfor
endfunction

function! <SID>s:Project_has_cli() dict
  return self.cli_exists
endfunction

function! <SID>s:Project_get_wordpress_path() dict
  return self.wordpress_project_path
endfunction

function! <SID>s:Project_has_wordpress_path() dict
  return isdirectory(self.get_wordpress_path())
endfunction

function! <SID>s:Project_destroy() dict
endfunction

function! <SID>s:Project_load_wpcli(root) dict
  let cli_path = self.lookup('wpcli_path')
  let self.cli_exists = cli_path.exists(a:root)
  if self.cli_exists
    let cli = self.get_wpcli()
    call cli.set_path(cli_path.get_path(a:root))
  endif
endfunction

function! <SID>s:Project_load_wordpress_path(root) dict
  let wordpress_path = self.lookup('wordpress_path')
  let self.wordpress_project_path = wordpress_path.get_path(a:root)
endfunction

function! <SID>s:Project_load_ctags_builder(root) dict
  if self.has_wordpress_path()
    let ctags_builder = self.lookup('ctags_builder')
    call ctags_builder.set_project_path(self.get_wordpress_path())
  endif
endfunction

function! <SID>s:Project_get_wpcli() dict
  return self.lookup('wpcli')
endfunction

function! s:ProjectCollectionConstructor()
  let projectCollectionObj = {}
  let projectCollectionObj.is_project_collection = 1
  let projectCollectionObj.projects = {}
  let projectCollectionObj.needs = function('<SNR>' . s:SID() . '_s:ProjectCollection_needs')
  let projectCollectionObj.lookup = function('<SNR>' . s:SID() . '_s:ProjectCollection_lookup')
  let projectCollectionObj.size = function('<SNR>' . s:SID() . '_s:ProjectCollection_size')
  let projectCollectionObj.add = function('<SNR>' . s:SID() . '_s:ProjectCollection_add')
  let projectCollectionObj.remove = function('<SNR>' . s:SID() . '_s:ProjectCollection_remove')
  let projectCollectionObj.contains = function('<SNR>' . s:SID() . '_s:ProjectCollection_contains')
  let projectCollectionObj.project_for = function('<SNR>' . s:SID() . '_s:ProjectCollection_project_for')
  let projectCollectionObj.clear = function('<SNR>' . s:SID() . '_s:ProjectCollection_clear')
  return projectCollectionObj
endfunction

function! <SID>s:ProjectCollection_needs() dict
  return ['project']
endfunction

function! <SID>s:ProjectCollection_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! <SID>s:ProjectCollection_size() dict
  return len(self.projects)
endfunction

function! <SID>s:ProjectCollection_add(project_path) dict
  if !(self.contains(a:project_path))
    let project = self.lookup('project')
    call project.load(a:project_path)
    let self.projects[a:project_path] = project
  endif
  return self.project_for(a:project_path)
endfunction

function! <SID>s:ProjectCollection_remove(project_path) dict
  if self.contains(a:project_path)
    unlet self.projects[a:project_path]
  endif
endfunction

function! <SID>s:ProjectCollection_contains(project_path) dict
  return has_key(self.projects, a:project_path)
endfunction

function! <SID>s:ProjectCollection_project_for(project_path) dict
  return self.projects[a:project_path]
endfunction

function! <SID>s:ProjectCollection_clear() dict
  for project in values(self.projects)
    call project.destroy()
  endfor
  let self.projects = {}
endfunction

" included: 'tags_option.riml'
function! s:TagsOptionConstructor()
  let tagsOptionObj = {}
  let tagsOptionObj.is_tags_option = 1
  let tagsOptionObj.append = function('<SNR>' . s:SID() . '_s:TagsOption_append')
  let tagsOptionObj.prepend = function('<SNR>' . s:SID() . '_s:TagsOption_prepend')
  let tagsOptionObj.get_tags = function('<SNR>' . s:SID() . '_s:TagsOption_get_tags')
  let tagsOptionObj.set_tags = function('<SNR>' . s:SID() . '_s:TagsOption_set_tags')
  let tagsOptionObj.to_list = function('<SNR>' . s:SID() . '_s:TagsOption_to_list')
  let tagsOptionObj.to_value = function('<SNR>' . s:SID() . '_s:TagsOption_to_value')
  return tagsOptionObj
endfunction

function! <SID>s:TagsOption_append(path) dict
  let tags = self.to_list(self.get_tags())
  call add(tags, a:path)
  let value = self.to_value(tags)
  call self.set_tags(value)
endfunction

function! <SID>s:TagsOption_prepend(path) dict
  let tags = self.to_list(self.get_tags())
  call insert(tags, a:path, 0)
  let value = self.to_value(tags)
  call self.set_tags(value)
endfunction

function! <SID>s:TagsOption_get_tags() dict
  return &tags
endfunction

function! <SID>s:TagsOption_set_tags(tags) dict
  execute ":setlocal tags=" . a:tags
endfunction

function! <SID>s:TagsOption_to_list(value) dict
  return split(a:value, ',')
endfunction

function! <SID>s:TagsOption_to_value(items) dict
  return join(a:items, ',')
endfunction

" included: 'container.riml'
function! s:ContainerConstructor(parent)
  let containerObj = {}
  let containerObj.is_container = 1
  let containerObj.parent = a:parent
  let containerObj.objects = {}
  let containerObj.register = function('<SNR>' . s:SID() . '_s:Container_register')
  let containerObj.unregister = function('<SNR>' . s:SID() . '_s:Container_unregister')
  let containerObj.lookup = function('<SNR>' . s:SID() . '_s:Container_lookup')
  let containerObj.has = function('<SNR>' . s:SID() . '_s:Container_has')
  let containerObj.has_parent = function('<SNR>' . s:SID() . '_s:Container_has_parent')
  let containerObj.inject = function('<SNR>' . s:SID() . '_s:Container_inject')
  let containerObj.child = function('<SNR>' . s:SID() . '_s:Container_child')
  let containerObj.get_parent = function('<SNR>' . s:SID() . '_s:Container_get_parent')
  return containerObj
endfunction

function! <SID>s:Container_register(name, classname, ...) dict
  if len(a:000) ==# 0
    let singleton = 0
  else
    let singleton = a:000[0]
  endif
  if type(a:classname) ==# type('')
    let object = s:ContainerObjectConstructor(a:classname, singleton)
  else
    let object = s:ContainerObjectConstructor('ExistingObject', 1)
    call object.set_instance(a:classname)
  endif
  let self.objects[a:name] = object
endfunction

function! <SID>s:Container_unregister(name, from_parent) dict
  if has_key(self.objects, a:name)
    unlet self.objects[a:name]
  endif
  if a:from_parent && self.has_parent()
    call self.parent.unregister(a:name, a:from_parent)
  endif
endfunction

function! <SID>s:Container_lookup(name) dict
  if has_key(self.objects, a:name)
    let object = self.objects[a:name]
    let instance = object.get_instance()
    call self.inject(instance)
    return instance
  elseif self.has_parent()
    return self.parent.lookup(a:name)
  else
    throw "Container object not found: " . a:name
  endif
endfunction

function! <SID>s:Container_has(name) dict
  return has_key(self.objects, a:name) || (self.has_parent() && self.parent.has(a:name))
endfunction

function! <SID>s:Container_has_parent() dict
  return has_key(self.parent, 'is_container')
endfunction

function! <SID>s:Container_inject(instance) dict
  if type(a:instance) !=# type({}) || has_key(a:instance, 'container')
    return
  endif
  if has_key(a:instance, 'needs')
    let needs = a:instance.needs()
    for need in needs
      let dependency = self.lookup(need)
      let a:instance[need] = dependency
    endfor
  endif
  let a:instance['container'] = self
  if has_key(a:instance, 'on_inject')
    call a:instance.on_inject()
  endif
endfunction

function! <SID>s:Container_child() dict
  return s:ContainerConstructor(self)
endfunction

function! <SID>s:Container_get_parent() dict
  return self.parent
endfunction

function! s:ContainerObjectConstructor(classname, singleton)
  let containerObjectObj = {}
  let containerObjectObj.classname = a:classname
  let containerObjectObj.singleton = a:singleton
  let containerObjectObj.is_container_object = 1
  let containerObjectObj.get_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_get_instance')
  let containerObjectObj.set_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_set_instance')
  let containerObjectObj.instantiated = function('<SNR>' . s:SID() . '_s:ContainerObject_instantiated')
  let containerObjectObj.needs_new_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_needs_new_instance')
  let containerObjectObj.create = function('<SNR>' . s:SID() . '_s:ContainerObject_create')
  return containerObjectObj
endfunction

function! <SID>s:ContainerObject_get_instance() dict
  if self.needs_new_instance()
    let Klass = function("s:" . self.classname . "Constructor")
    let self.instance_object = self.create(Klass)
  endif
  return self.instance_object
endfunction

function! <SID>s:ContainerObject_set_instance(instance) dict
  let self.instance_object = a:instance
endfunction

function! <SID>s:ContainerObject_instantiated() dict
  return has_key(self, 'instance_object')
endfunction

function! <SID>s:ContainerObject_needs_new_instance() dict
  return !self.instantiated() || !self.singleton
endfunction

function! <SID>s:ContainerObject_create(Klass) dict
  return a:Klass()
endfunction

" included: 'configure_buffer_command.riml'
function! s:ConfigureBufferCommandConstructor(container)
  let configureBufferCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(configureBufferCommandObj, wordPressCommandObj)
  let configureBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ConfigureBufferCommand_get_name')
  let configureBufferCommandObj.run = function('<SNR>' . s:SID() . '_s:ConfigureBufferCommand_run')
  return configureBufferCommandObj
endfunction

function! <SID>s:ConfigureBufferCommand_get_name() dict
  return 'ConfigureBuffer'
endfunction

function! <SID>s:ConfigureBufferCommand_run(buffer, opts) dict
  let buffer_collection = self.lookup('buffer_collection')
  call buffer_collection.add(a:buffer)
endfunction

" included: 'change_current_buffer_command.riml'
function! s:ChangeCurrentBufferCommandConstructor(container)
  let changeCurrentBufferCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(changeCurrentBufferCommandObj, wordPressCommandObj)
  let changeCurrentBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ChangeCurrentBufferCommand_get_name')
  let changeCurrentBufferCommandObj.run = function('<SNR>' . s:SID() . '_s:ChangeCurrentBufferCommand_run')
  return changeCurrentBufferCommandObj
endfunction

function! <SID>s:ChangeCurrentBufferCommand_get_name() dict
  return 'ChangeCurrentBuffer'
endfunction

function! <SID>s:ChangeCurrentBufferCommand_run(buffer, opts) dict
  let buffer_collection = self.lookup('buffer_collection')
  let project_collection = self.lookup('project_collection')
  let project_path = a:buffer.get_project_path()
  let project_added = 0
  call buffer_collection.set_current(a:buffer)
  if !(project_collection.contains(project_path))
    let project = project_collection.add(project_path)
    let project_added = 1
  endif
  if project_collection.contains(project_path)
    call self.process('LoadProjectRegistry')
    call self.process('LoadSyntax')
    call self.process('ConfigureTags')
  endif
  if project_added
    redraw
    call s:echo_msg("WordPress: Loading ... DONE")
  endif
endfunction

" included: 'load_syntax_command.riml'
function! s:LoadSyntaxCommandConstructor(container)
  let loadSyntaxCommandObj = {}
  let wordPressCommandObj = s:WordPressCommandConstructor(a:container)
  call extend(loadSyntaxCommandObj, wordPressCommandObj)
  let loadSyntaxCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_get_name')
  let loadSyntaxCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_run')
  let loadSyntaxCommandObj.is_php_buffer = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_is_php_buffer')
  let loadSyntaxCommandObj.is_readme_buffer = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_is_readme_buffer')
  let loadSyntaxCommandObj.load_php_syntax = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_load_php_syntax')
  let loadSyntaxCommandObj.load_readme_syntax = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_load_readme_syntax')
  return loadSyntaxCommandObj
endfunction

function! <SID>s:LoadSyntaxCommand_get_name() dict
  return 'LoadSyntax'
endfunction

function! <SID>s:LoadSyntaxCommand_run(opts) dict
  if self.is_php_buffer()
    call self.load_php_syntax()
  elseif self.is_readme_buffer()
    call self.load_readme_syntax()
  endif
endfunction

function! <SID>s:LoadSyntaxCommand_is_php_buffer() dict
  return &filetype ==# 'php'
endfunction

function! <SID>s:LoadSyntaxCommand_is_readme_buffer() dict
  return self.current_buffer_full_path() =~# 'readme.txt'
endfunction

function! <SID>s:LoadSyntaxCommand_load_php_syntax() dict
  set filetype=php.wordpress
endfunction

function! <SID>s:LoadSyntaxCommand_load_readme_syntax() dict
  set filetype=markdown.readme
endfunction

" included: 'load_project_registry_command.riml'
function! s:LoadProjectRegistryCommandConstructor(container)
  let loadProjectRegistryCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(loadProjectRegistryCommandObj, wordPressProjectCommandObj)
  let loadProjectRegistryCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadProjectRegistryCommand_get_name')
  let loadProjectRegistryCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadProjectRegistryCommand_run')
  return loadProjectRegistryCommandObj
endfunction

function! <SID>s:LoadProjectRegistryCommand_get_name() dict
  return 'LoadProjectRegistry'
endfunction

function! <SID>s:LoadProjectRegistryCommand_run(opts) dict
  let registry = self.lookup('project_registry')
  call registry.register_commands()
endfunction

" included: 'configure_tags_command.riml'
function! s:ConfigureTagsCommandConstructor(container)
  let configureTagsCommandObj = {}
  let wordPressProjectCommandObj = s:WordPressProjectCommandConstructor(a:container)
  call extend(configureTagsCommandObj, wordPressProjectCommandObj)
  let configureTagsCommandObj.is_configure_tags_command = 1
  let configureTagsCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ConfigureTagsCommand_get_name')
  let configureTagsCommandObj.run = function('<SNR>' . s:SID() . '_s:ConfigureTagsCommand_run')
  let configureTagsCommandObj.generate_ctags = function('<SNR>' . s:SID() . '_s:ConfigureTagsCommand_generate_ctags')
  let configureTagsCommandObj.configure_tag_option = function('<SNR>' . s:SID() . '_s:ConfigureTagsCommand_configure_tag_option')
  return configureTagsCommandObj
endfunction

function! <SID>s:ConfigureTagsCommand_get_name() dict
  return 'ConfigureTags'
endfunction

function! <SID>s:ConfigureTagsCommand_run(opts) dict
  let buffer = self.current_buffer()
  let project = self.current_project()
  if project.has_wordpress_path()
    call self.generate_ctags()
  endif
  call self.configure_tag_option()
endfunction

function! <SID>s:ConfigureTagsCommand_generate_ctags() dict
  let ctags_builder = self.lookup('ctags_builder')
  if !(ctags_builder.has_tags())
    redraw
    call s:echo_msg("WordPress: Generating ctags ...")
    call ctags_builder.generate()
  endif
endfunction

function! <SID>s:ConfigureTagsCommand_configure_tag_option() dict
  let ctags_builder = self.lookup('ctags_builder')
  let tags_option = self.lookup('tags_option')
  if ctags_builder.has_tags()
    let tags_path = fnamemodify(ctags_builder.get_project_tags(), ':p')
    call tags_option.prepend(tags_path)
  endif
endfunction

function! s:ControllerConstructor()
  let controllerObj = {}
  let controllerObj.container = s:ContainerConstructor({})
  let controllerObj.process = function('<SNR>' . s:SID() . '_s:Controller_process')
  let controllerObj.load = function('<SNR>' . s:SID() . '_s:Controller_load')
  let controllerObj.configure_container = function('<SNR>' . s:SID() . '_s:Controller_configure_container')
  let controllerObj.load_commands = function('<SNR>' . s:SID() . '_s:Controller_load_commands')
  let controllerObj.lookup = function('<SNR>' . s:SID() . '_s:Controller_lookup')
  return controllerObj
endfunction

function! <SID>s:Controller_process(...) dict
  let registry = self.container.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! <SID>s:Controller_load() dict
  call self.configure_container()
  call self.load_commands()
endfunction

function! <SID>s:Controller_configure_container() dict
  let c = self.container
  call c.register('registry', 'CommandRegistry', 1)
  call c.register('buffer_collection', 'BufferCollection', 1)
  call c.register('project_collection', 'ProjectCollection', 1)
  call c.register('project', 'Project', 0)
  call c.register('with_dir', 'WithDir', 0)
  call c.register('file_opener', 'FileOpener', 0)
  call c.register('tags_option', 'TagsOption', 1)
endfunction

function! <SID>s:Controller_load_commands() dict
  let c = self.container
  let r = c.lookup('registry')
  call r.add(s:ConfigureBufferCommandConstructor(c))
  call r.add(s:ChangeCurrentBufferCommandConstructor(c))
  call r.add(s:LoadSyntaxCommandConstructor(c))
  call r.add(s:LoadProjectRegistryCommandConstructor(c))
  call r.add(s:ConfigureTagsCommandConstructor(c))
endfunction

function! <SID>s:Controller_lookup(key) dict
  return self.container.lookup(a:key)
endfunction

function! s:AppConstructor()
  let appObj = {}
  let appObj.controller = s:ControllerConstructor()
  let appObj.start = function('<SNR>' . s:SID() . '_s:App_start')
  let appObj.on_buffer_open = function('<SNR>' . s:SID() . '_s:App_on_buffer_open')
  let appObj.on_buffer_enter = function('<SNR>' . s:SID() . '_s:App_on_buffer_enter')
  let appObj.on_buffer_leave = function('<SNR>' . s:SID() . '_s:App_on_buffer_leave')
  return appObj
endfunction

function! <SID>s:App_start() dict
  call self.controller.load()
endfunction

function! <SID>s:App_on_buffer_open(buffer) dict
  return self.controller.process('ConfigureBuffer', a:buffer)
endfunction

function! <SID>s:App_on_buffer_enter(buffer) dict
  return self.controller.process('ChangeCurrentBuffer', a:buffer)
endfunction

function! <SID>s:App_on_buffer_leave(buffer) dict
endfunction

function! wordpress#app()
  if !(exists('s:app'))
    let s:app = s:AppConstructor()
    call s:app.start()
    let g:wordpress_vim_loaded = 1
  endif
  return s:app
endfunction
